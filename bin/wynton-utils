#! /usr/bin/env bash
#' Wynton Utilities
#'
#' Usage:
#'  wynton-utils [options] <utility>
#'
#' Flags:
#'  --help           Display this help
#'  --version        Display version
#'  --apply          Load and apply (default is just to load)
#'
#' Examples:
#'  eval $(wynton utils fuse-tmpdir --apply)  ## load & apply utility
#'
#'  ## Same, but in two explicit steps
#'  eval $(wynton utils fuse-tmpdir)          ## load utility
#'  eval $(fuse-tmpdir)                       ## apply utility
#'
#'  wynton utils fuse-tmpdir                  ## view code and help
#'
#' License: See 'wynton --help'
call="$0 $*"

this="${BASH_SOURCE%/}"
[[ -L "${this}" ]] && this=$(readlink "${this}")

## Import bash utility functions
incl="$(dirname "${this}")/incl"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"
# shellcheck source=incl/system.sh
source "${incl}/system.sh"


# -------------------------------------------------------------------------
# SPECIFIC
# -------------------------------------------------------------------------


# -------------------------------------------------------------------------
# MAIN
# -------------------------------------------------------------------------
## Utility
util=

## Options
debug=false
verbose=false
apply=false

# Parse command-line options
while [[ $# -gt 0 ]]; do
    if test "$1" == "--help"; then
        action=help
    elif test "$1" == "--version"; then
        action=version
    elif test "$1" == "--debug"; then
        debug=true
    elif test "$1" == "--verbose"; then
        verbose=true
    elif test "$1" == "--apply"; then
        apply=true
    else
        if [[ -n "${util}" ]]; then
            error "Utility argument already specified: $1"
        fi
        util="$1"
    fi
    shift
done

if $debug; then
    mdebug "call: $call"
    mdebug "verbose: $verbose"
    mdebug "util: $util"
    mdebug "apply: $apply"
fi

if [[ $action == "version" ]]; then
    version
    exit 0
elif [[ $action == "help" ]]; then
    help ""
    exit 0
fi

if [[ -z "${util}" ]]; then
   error "Utility argument not specified"
fi

path="$(dirname "${this}")/utils"
assert_dir_exists "${path}"

file=${path}/${util}.sh
assert_file_exists "${file}"

## Read utility source code
mapfile code < <(cat "${file}")

cmd=
if ${apply}; then
    pattern="^#+[[:blank:]]*apply:[[:blank:]]*"
    cmd=$(grep -E "${pattern}" <<< "$(printf "%s\n" "${code[@]}")")
    if [[ -z ${cmd} ]]; then
        error "The '${util}' utility does not have a '# apply: ...' declaration required for --apply: ${file}"
    fi
    cmd=$(sed -E "s/${pattern}//" <<< "${cmd}")
fi

printf "%s\n" "${code[@]}"

if [[ -n ${cmd} ]]; then
    echo "# Apply '${util}' utility"
    echo "${cmd}"
fi
