#! /usr/bin/env bash
#' Wynton Account Validation
#'
#' Usage:
#'  wynton-account [options]
#'
#' Options:
#'  --user USER      Query another user (default: $USER)
#'  --help           Display this help
#'  --version        Display version
#'
#' Examples:
#'  wynton account
#'  wynton account --user alice
#'
#' Version: 0.0.1
#' Copyright: Henrik Bengtsson (2024)
#' License: GPL (>= 2.1) [https://www.gnu.org/licenses/gpl.html]
call="$0 $*"

this="${BASH_SOURCE%/}"
[[ -L "${this}" ]] && this=$(readlink "${this}")

utils="$(dirname "${this}")/utils"

## Import bash utility functions
incl="$(dirname "${this}")/incl"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"
# shellcheck source=incl/system.sh
source "${incl}/system.sh"
# shellcheck source=incl/ldap.sh
source "${incl}/ldap.sh"


# -------------------------------------------------------------------------
# SPECIFIC
# -------------------------------------------------------------------------


# -------------------------------------------------------------------------
# MAIN
# -------------------------------------------------------------------------
## Actions
action=validate

## Options
debug=false
verbose=false
user=${USER}

# Parse command-line options
while [[ $# -gt 0 ]]; do
    if test "$1" == "--help"; then
        action=help
    elif test "$1" == "--version"; then
        action=version
    elif test "$1" == "--debug"; then
        debug=true
    elif test "$1" == "--verbose"; then
        verbose=true
	
    ## Deprecated
    elif test "$1" == "--user"; then
	shift
        user=$1
	mdeprecated "Command-line option format '$1 <value>' is deprecated. Please use '$1=<value>' instead"
	
    ## Options (--key=value):
    elif [[ "$1" =~ ^--.*=.*$ ]]; then
        key=${1//--}
        key=${key//=*}
        value=${1//--[[:alpha:]]*=}
        mdebug "Key-value option '$1' parsed to key='${key}', value='${value}'"
        if [[ -z ${value} ]]; then
            error "Option '--${key}' must not be empty"
        fi
        if [[ "${key}" == "user" ]]; then
            user=${value}
        else
            error "Unknown option: $1"
        fi
     else
        extras="$extras $1"
    fi
    shift
done

## Assert that user exists
id --user "$user" &> /dev/null || error "No such user: $user"


if [[ $user == "$USER" ]]; then
    home=$HOME
else
    home=$(getent passwd "$user" | cut -d: -f6)
fi

uid=$(id --user "$user")
gid=$(id --group "$user")
group=$(id --group --name "$user")

if $debug; then
    mdebug "call: $call"
    mdebug "action: $action"
    mdebug "verbose: $verbose"
    mdebug "user: $user"
    mdebug "group: $group"
    mdebug "uid: $uid"
    mdebug "gid: $gid"
    mdebug "home: $home"
fi

if [[ $action == "version" ]]; then
    version
    exit 0
elif [[ $action == "help" ]]; then
    help ""
    exit 0
fi

if [[ $action == "validate" ]]; then
    n_ok=0
    n_fail=0
    n_skip=0

    same_user=true
    if [[ "${user}" != "${USER}" ]]; then
        same_user=false
	warn "Running as user '${USER}' != '${user}'"
	echo >&2
    fi
    
    mapfile -t ldap_info < <(ldap_search "uid=${user}" "+" "*" | sort)
    printf "%s\n" "${ldap_info[@]}"

    # No duplicated username
    count=$(ldap_get_field "uid" "${ldap_info[@]}" | wc -l)
    if [[ ${count} -gt 1 ]]; then
	error "There are ${count} users in LDAP with username '${user}'"
    fi

    phi=false
    if [[  $(ldap_get_field "protectedAccess" "${ldap_info[@]}") == "TRUE" ]]; then
	phi=true
    fi

    if ${same_user}; then
	running_as_phi=${phi}
    else
	if [[ "$(ldap_search "uid=${USER}" "protectedAccess" | ldap_get_field "protectedAccess")" == "TRUE" ]]; then
            running_as_phi=true
	else
            running_as_phi=false
	fi
    fi
    if [[ ${running_as_phi} != ${phi} ]]; then
        warn "Cannot run all checks on PHI user, because running as a non-PHI user"
	echo >&2
    fi
    
    access=false
    if [[  $(ldap_get_field "wyntonAccess" "${ldap_info[@]}") == "TRUE" ]]; then
	access=true
    fi

    email=$(ldap_get_field "mail" "${ldap_info[@]}")
    ucsf_id=$(ldap_get_field "ucsfIDNumber" "${ldap_info[@]}")
    
    echo "# Account Validation"
    echo
    echo "## Overview"
    echo
    echo "* User: $user (uid=$uid)"
    echo "* Group: $group (gid=$gid)"
    echo "* HOME: $home"
    echo "* Email address: ${email}"
    echo "* UCSF Employee ID: ${ucsf_id}"
    echo "* Wynton account: ${access}"
    echo "* PHI account: ${phi}"
    ts=$(ldap_get_field "createTimestamp" "${ldap_info[@]}")
    echo "* Account created on: $(ldap_as_timestamp "${ts}")"
    ts=$(ldap_get_field "modifyTimestamp" "${ldap_info[@]}")
    echo "* Account last-modified on: $(ldap_as_timestamp "${ts}")"
    echo
    
    echo "## Checks"
    echo
    
    echo "[ OK ] Username is unique"  ## validated above
    
    # No duplicated UID
    mapfile -t res < <(ldap_search "uidNumber=${uid}" "uid" | ldap_get_field "uid")
    if [[ ${#res[@]} -gt 1 ]]; then
	echo "[FAIL] User ID is not unique: [n=${res[@]}] ${res[*]}"
	n_fail=$((n_fail + 1))
    else
	echo "[ OK ] User ID is unique"
	n_ok=$((n_ok + 1))
    fi

    # UIDs within [1023,65535]
    if [[ ${UID} -lt 1023 ]] || [[ ${UID} -gt 65535 ]]; then
	echo "[FAIL] User ID is out of range [1023,65535]"
	n_fail=$((n_fail + 1))
    else
	echo "[ OK ] User ID is within [1023,65535]"
	n_ok=$((n_ok + 1))
    fi

    # No 'reserved' usernames
    mapfile -t reserved < <(reserved_usernames)
    if [[ " ${reserved[@]} " =~ " ${user} " ]]; then
	echo "[FAIL] Username is a 'reserved' username and should not be used"
	n_fail=$((n_fail + 1))
    else
	echo "[ OK ] Username is not a 'reserved' username"
	n_ok=$((n_ok + 1))
    fi

    # No duplicated home directories
    mapfile -t res < <(ldap_search "homeDirectory=${home}" "homeDirectory" | ldap_get_field "homeDirectory")
    if [[ ${#res[@]} -gt 1 ]]; then
	echo "[FAIL] User HOME folder is not unique: [n=${res[@]}] ${res[*]}"
	n_fail=$((n_fail + 1))
    else
	echo "[ OK ] User HOME folder is unique"
	n_ok=$((n_ok + 1))
    fi
    
    # Users has a HOME directories under expected /wynton/ location
    if ${phi}; then
	expected="/wynton/protected/home/{group}/"
    else
	expected="/wynton/home/{group}/"
    fi
    pattern=$(sed 's/{group}/[[:alnum:]_.-]+/' <<< "${expected}")
    if grep -q -E "^${pattern}" <<< "${home}"; then
	echo "[ OK ] User HOME folder is under ${expected}"
	n_ok=$((n_ok + 1))
    else
	echo "[FAIL] User HOME folder is not under ${expected}"
	n_fail=$((n_fail + 1))
    fi

    if [[ ${EUID} -ne 0 ]] && ${phi} && ! ${running_as_phi}; then
	skip=true
    else
        skip=false
    fi

    if ${skip}; then
        echo "[SKIP] HOME folder exists"
        echo "[SKIP] HOME folder is owned by user"
        n_skip=$((n_skip + 2))
    else
        if [[ -d "${home}" ]]; then
            echo "[ OK ] HOME folder exists"
            n_ok=$((n_ok + 1))
        else
            echo "[FAIL] HOME folder does not exist"
            n_fail=$((n_fail + 1))
        fi
        
        if [[ $(stat --format="%u" "${home}") == "${uid}" ]]; then
            echo "[ OK ] HOME folder is owned by user"
            n_ok=$((n_ok + 1))
        else
            echo "[FAIL] HOME folder is not owned by user"
            n_fail=$((n_fail + 1))
        fi
    fi

    # No duplicated email addresses
    mapfile -t res < <(ldap_search "mail=${email}" "mail" | ldap_get_field "mail")
    if [[ ${#res[@]} -gt 1 ]]; then
	echo "[FAIL] User email address is not unique: [n=${res[@]}] ${res[*]}"
	n_fail=$((n_fail + 1))
    else
	echo "[ OK ] User email address is unique"
	n_ok=$((n_ok + 1))
    fi
    
    # Valid email address
    if grep -q -i -E "$(email_pattern)" <<< "${email}"; then
	echo "[ OK ] User email address has a valid format"
	n_ok=$((n_ok + 1))
    else
	echo "[FAIL] User email address does not have a valid format"
	n_fail=$((n_fail + 1))
    fi

    # Valid UCSF ID
    if valid_ucsf_id "${ucsf_id}"; then
	echo "[ OK ] User UCSF Employee ID is valid"
	n_ok=$((n_ok + 1))
    else
	echo "[FAIL] User UCSF Employee ID is invalid"
	n_fail=$((n_fail + 1))
    fi
    
    echo
    echo "Summary: ${n_ok} OK, ${n_fail} FAIL, ${n_skip} SKIP"

    if [[ ${n_fail} -gt 0 ]]; then
	echo >&2
        error "Detected ${n_fail} FAIL:s"
    fi
fi

