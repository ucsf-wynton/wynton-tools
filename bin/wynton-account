#! /usr/bin/env bash
#' Wynton Account Information
#'
#' Looks up a Wynton user account, outputs a summary, and,
#' optionally, checks its settings.
#'
#' Usage:
#'  wynton-account [options] <user>
#'
#' Flags:
#'  --help           Display this help
#'  --version        Display version
#'  --check          Checks the account settings
#'
#' Arguments:
#'  <user>           User to query (default: $USER)
#'
#' Examples:
#'  wynton account
#'  wynton account alice
#'  wynton account 1000
#'  wynton account alice@bobsonlab.org
#'  wynton account alice --check
#'
#' License: See 'wynton --help'
call="$0 $*"

this="${BASH_SOURCE%/}"
[[ -L "${this}" ]] && this=$(readlink "${this}")

utils="$(dirname "${this}")/utils"

## Import bash utility functions
incl="$(dirname "${this}")/incl"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"
# shellcheck source=incl/system.sh
source "${incl}/system.sh"
# shellcheck source=incl/ldap.sh
source "${incl}/ldap.sh"


# -------------------------------------------------------------------------
# SPECIFIC
# -------------------------------------------------------------------------
function outcome {
    local state=${1:?}
    local -i color=${2:?}
    
    printf "%s" "["
    _tput setaf "${color}"
    printf "%s" "${state}"
    _tput sgr0    ## reset
    printf "%s" "]"
    shift
    shift
    echo " $*"
}    

n_okay=0
function okay {
    outcome " OK " 2 "$@" ## green
    n_okay=$((n_okay + 1))
}

n_fail=0
function fail {
    outcome "FAIL" 1 "$@" ## red
    n_fail=$((n_fail + 1))
}

n_note=0
function note {
    outcome "NOTE" 3 "$@" ## yellow
    n_note=$((n_note + 1))
}

n_skip=0
function skip {
    outcome "SKIP" 8 "$@" ## gray
    n_skip=$((n_skip + 1))
}


function beegfs_user_quota {
    local -i uid=${1:?}
    local -i beegfs_storagepool=11

    beegfs-ctl --getquota --csv --storagepoolid="${beegfs_storagepool}" --uid "${uid}" | awk -F "," 'NR > 1 {
        used=$3
        max=$4
        chunks=$5
        if (used ~ /[^0-9]/) used = -1
        if (max ~ /[^0-9]/) max = -1
        printf "%d\n%d\n%d\n%.1f\n%d\n", used, max, max-used, 100*used/max, chunks
    }'
}

function beegfs_group_quota {
    local -i gid=${1:?}
    local -i beegfs_storagepool=12

    beegfs-ctl --getquota --csv --storagepoolid="${beegfs_storagepool}" --gid "${gid}" | awk -F "," 'NR > 1 {
        used=$3
        max=$4
        chunks=$5
        if (used ~ /[^0-9]/) used = -1
        if (max ~ /[^0-9]/) max = -1
        printf "%d\n%d\n%d\n%.1f\n%d\n%", used, max, max-used, 100*used/max, chunks
    }'
}

function skip_group_quota {
    grep -q -E "^(icusers|lsd|qb3|quotagroup|sbgrid|vglusers|wynton-rotation|wynton-phi)$" <<< "${1:?}"
}

function pretty_int {
    local -i value=${1:?}
    LC_NUMERIC=en_US.UTF-8 printf "%'d\n" "${value}"
}


# -------------------------------------------------------------------------
# MAIN
# -------------------------------------------------------------------------
## Actions
action=validate

## Options
check=false
debug=false
user=

# Parse command-line options
while [[ $# -gt 0 ]]; do
    if test "$1" == "--help"; then
        action=help
    elif test "$1" == "--version"; then
        action=version
    elif test "$1" == "--debug"; then
        debug=true
    elif test "$1" == "--check"; then
        check=true

    ## Options (--key=value):
    elif [[ "$1" =~ ^--.*=.*$ ]]; then
        key=${1//--}
        key=${key//=*}
        value=${1//--[[:alpha:]]*=}
        mdebug "Key-value option '$1' parsed to key='${key}', value='${value}'"
        if [[ -z ${value} ]]; then
            error "Option '--${key}' must not be empty"
        fi
        if [[ "${key}" == "user" ]]; then
            eval "user=\$(as_user '${value}')"
        else
            error "Unknown option: $1"
        fi
	
    elif [[ "$1" =~ ^--.*$ ]]; then
        error "Unknown option: $1"
	
    else
        if [[ -n "${user}" ]]; then
            error "Argument <user> is already specified: $1"
	fi
        eval "user=\$(as_user '$1')"
    fi
    
    shift
done

if [[ -z "${user}" ]]; then
    user=${USER}
fi

## Assert that user exists
id --user "$user" &> /dev/null || error "No such user: $user"

if [[ $user == "$USER" ]]; then
    home=$HOME
else
    home=$(getent passwd "$user" | cut -d: -f6)
fi

uid=$(id --user "$user" 2> /dev/null)
gid=$(id --group "$user" 2> /dev/null)
group=$(id --group --name "$user" 2> /dev/null)
mapfile -t gids < <(id --groups "${user}" 2> /dev/null | tr ' ' $'\n')
mapfile -t groups < <(id --groups --name "${user}" 2> /dev/null | tr ' ' $'\n')

if $debug; then
    mdebug "call: $call"
    mdebug "action: $action"
    mdebug "check: $check"
    mdebug "user: $user"
    mdebug "group: $group"
    mdebug "groups: [n=${#groups[@]}] ${groups[*]}"
    mdebug "gids: [n=${#gids[@]}] ${gids[*]}"
    mdebug "uid: $uid"
    mdebug "gid: $gid"
    mdebug "home: $home"
fi

if [[ $action == "version" ]]; then
    version
    exit 0
elif [[ $action == "help" ]]; then
    help ""
    exit 0
fi

if [[ $action == "validate" ]]; then
    n_okay=0
    n_note=0
    n_fail=0
    n_skip=0

    same_user=true
    if [[ "${user}" != "${USER}" ]]; then
        same_user=false
        footnote "${yellow}WARNING: Running as user '${USER}' != '${user}'${reset}"
    fi
    
    mapfile -t ldap_info < <(ldap_search "uid=${user}" "+" "*" | sort)
    #    printf "%s\n" "${ldap_info[@]}"
    
    # No duplicated username
    count=$(ldap_get_field "uid" "${ldap_info[@]}" | wc -l)
    if [[ ${count} -gt 1 ]]; then
        error "There are ${count} users in LDAP with username '${user}'"
    fi

    ## Access to PHI?
    phi=false
    if [[  $(ldap_get_field "protectedAccess" "${ldap_info[@]}") == "TRUE" ]]; then
        phi=true
    fi

    if ${same_user}; then
        running_as_phi=${phi}
    else
        if [[ "$(ldap_search "uid=${USER}" "protectedAccess" | ldap_get_field "protectedAccess")" == "TRUE" ]]; then
            running_as_phi=true
        else
            running_as_phi=false
        fi
    fi
    if [[ ${running_as_phi} != "${phi}" ]]; then
        footnote "${yellow}WARNING: Cannot run all checks on PHI user, because running as a non-PHI user${reset}"
    fi
    
    ## Access to Wynton?
    access=false
    if [[  $(ldap_get_field "wyntonAccess" "${ldap_info[@]}") == "TRUE" ]]; then
        access=true
    fi

    ## Wynton admin account?
    admin=false
    if [[  $(ldap_get_field "wyntonAdmin" "${ldap_info[@]}") == "TRUE" ]]; then
        admin=true
    fi
    
    ## Is account locked?
    locked=false
    if [[  $(ldap_get_field "isLocked" "${ldap_info[@]}") == "TRUE" ]]; then
        locked=true
    fi
    
    email=$(ldap_get_field "mail" "${ldap_info[@]}")
    ucsf_id=$(ldap_get_field "ucsfIDNumber" "${ldap_info[@]}" | grep -i -v -E "^(none)$")
    shell=$(ldap_get_field "loginShell" "${ldap_info[@]}")
    faculty_sponsor=$(ldap_get_field "FacultySponsor" "${ldap_info[@]}")
    wynton_project=$(ldap_get_field "wyntonProject" "${ldap_info[@]}")

    ## Access to Information Commons, i.e. an "IC user"?
    if id "${user}" | grep -q -F "(icusers)"; then
        ic=true
    else
        ic=false
    fi

    ## Access to Plato, i.e. a "Plato account"?
    plato=false
    if [[  $(ldap_get_field "platoAccess" "${ldap_info[@]}") == "TRUE" ]]; then
        plato=true
    fi

    ## SGE information
    if qconf -suserl | grep -q -E "^${user}$"; then
        in_sge=true
        mapfile -t sge_info < <(qconf -suser "${user}" | sort)
        sge_project=$(printf "%s\n" "${sge_info[@]}" | grep -E "^default_project" | sed -E 's/^default_project[[:space:]]+//')
    else
        in_sge=false
        sge_info=()
        sge_project=
    fi


    # Disk quota
    mapfile -t beegfs_home_quota < <(beegfs_user_quota "${uid}")

    echo "# Account Information"
    echo
    echo "## Overview"
    echo
    echo "* User: ${user} (${uid:-N/A})"
    echo "* Groups: [n=${#groups[@]}]"
    for kk in $(seq "${#groups[@]}"); do
        n_members=$(ldap_search -b "ou=Groups,dc=cgl,dc=ucsf,dc=edu" "cn=${groups[$((kk-1))]}" | grep -c -E "^member:")        
        if [[ ${kk} -eq 1 ]]; then
            type="primary"
        else
            type="secondary"
        fi
        echo "  - '${groups[$((kk-1))]}' (${type}; ${gids[$((kk-1))]}; ${n_members} members)"
    done
    echo "* Full name: $(ldap_get_field "cn" "${ldap_info[@]}")"
    echo "* Email address: ${email:-N/A}"
    echo "* UCSF Employee ID: ${ucsf_id:-N/A}"
    if [[ -z "${faculty_sponsor}" ]]; then
        echo "* Faculty sponsor: N/A"
    else
        n_members=$(ldap_search "FacultySponsor=${faculty_sponsor}" | grep -c -E "^uid:")
        echo "* Faculty sponsor: ${faculty_sponsor} (${n_members} sponsees)"
    fi
    echo "* HOME: ${home:-N/A}"
    echo "* HOME disk quota: $(pretty_int "$(( beegfs_home_quota[0] / 1024**3 / 2 ))") GiB (${beegfs_home_quota[3]}%) used out of $(pretty_int "$(( beegfs_home_quota[1] / 1024**3 / 2 ))") GiB (buddy mirrored)"
    for kk in $(seq "${#groups[@]}"); do
        group_kk=${groups[$((kk-1))]}
        if skip_group_quota "${group_kk}"; then
            continue
        fi
        gid_kk=${gids[$((kk-1))]}
        mapfile -t quota < <(beegfs_group_quota "${gid_kk}")
        if [[ ${kk} -eq 1 ]]; then
            echo "* Group disk quotas (assuming no buddy mirroring):"
        fi
        if [[ ${quota[1]} -le 0 ]]; then
            echo "  - '${group_kk}': unlimited"
        elif [[ ${quota[1]} -le 1 ]]; then
            echo "  - '${group_kk}': not available"
        else
            buddy_mirrored=false
            if ${buddy_mirrored}; then
                echo "  - '${group_kk}': $(pretty_int "$(( quota[0] / 1024**3 /2 ))") GiB (${quota[3]}%) used out of $(pretty_int "$(( quota[1] / 1024**3 / 2 ))") GiB (buddy mirrored)"
            else
                echo "  - '${group_kk}': $(pretty_int "$(( quota[0] / 1024**3 ))") GiB (${quota[3]}%) used out of $(pretty_int "$(( quota[1] / 1024**3 ))") GiB"
            fi
       fi
    done
    echo "* HOME file chunks: $(pretty_int "${beegfs_home_quota[4]}")"
    echo "* Wynton access: ${access:-N/A}"
    echo "* PHI access: ${phi:-N/A}"
    echo "* IC access: ${ic:-N/A}"
    echo "* Plato access: ${plato:-N/A}"
    echo "* Wynton admin: ${admin:-N/A}"
    echo "* Locked account: ${locked:-N/A}"
    echo "* Login shell: ${shell:-N/A}"
    if [[ -z "${wynton_project}" ]]; then
        echo "* wynton_project: N/A"
    else
        n_members=$(ldap_search "wyntonProject=${wynton_project}" | grep -c -E "^uid:")
        echo "* Wynton project: ${wynton_project} (${n_members} members)"
    fi
   
    echo "* SGE project: ${sge_project:-N/A}"
    
    ts=$(ldap_get_field "createTimestamp" "${ldap_info[@]}")
    ts=$(ldap_as_timestamp "${ts}")
    age=$(ldap_timestamp_age "${ts}")
    by=$(ldap_get_field "creatorsName" "${ldap_info[@]}" | sed -E 's/(^uid=|,.*)//g')
    echo "* Account created on: ${ts} [${age} by '${by:-N/A}']"
    ts=$(ldap_get_field "modifyTimestamp" "${ldap_info[@]}")
    ts=$(ldap_as_timestamp "${ts}")
    age=$(ldap_timestamp_age "${ts}")
    by=$(ldap_get_field "modifiersName" "${ldap_info[@]}" | sed -E 's/(^uid=|,.*)//g')
    echo "* Account last-modified on: ${ts} [${age} by '${by:-N/A}']"

    if ${check}; then
        echo
        echo "## Checks"
        echo
    
        okay "Username is unique"  ## validated above
        
        # No 'reserved' usernames
        mapfile -t reserved < <(reserved_usernames)
        if [[ " ${reserved[*]} " =~ [[:space:]]${user}[[:space:]] ]]; then
            fail "Username is a 'reserved' username and should not be used"
        else
            okay "Username is not a 'reserved' username"
        fi
    
        # No duplicated UID
        mapfile -t res < <(ldap_search "uidNumber=${uid}" "uid" | ldap_get_field "uid")
        if [[ ${#res[@]} -gt 1 ]]; then
            fail "User ID (UID) is not unique: [n=${#res[@]}] ${res[*]}"
        else
            okay "User ID (UID) is unique"
        fi
    
        # UIDs within [1000,65535]
        if [[ ${uid} -lt 1000 ]] || [[ ${uid} -gt 65535 ]]; then
            fail "User ID (UID) is out of range [1000,65535]"
        else
            okay "User ID (UID) is within [1000,65535]"
        fi
    
        # GIDs within [455,65535]
        if [[ ${gid} -lt 455 ]] || [[ ${gid} -gt 65535 ]]; then
            fail "Group ID (GID) is out of range [455,65535]"
        else
            okay "Group ID (GID) is within [415,65535]"
        fi

        # GIDs exist
        if [[ ${gid} -lt 455 ]] || [[ ${gid} -gt 65535 ]]; then
            fail "Group ID (GID) is out of range [455,65535]"
        else
            okay "Group ID (GID) is within [415,65535]"
        fi

        invalid=()
        for kk in $(seq "${#gids[@]}"); do
                gid_kk=${gids[$((kk-1))]}
            if ! getent group "${gid_kk}" > /dev/null; then
                invalid+=("${gid_kk}")
            fi
        done
        if [[ ${#invalid[@]} -eq 0 ]]; then
            okay "All GIDs exist"
        else
            fail "All GIDs exist"
        fi

        # IC access => PHI access
        if ${ic}; then
            if ${phi}; then
                okay "IC user has PHI access"
            else
                fail "IC user without PHI access"
            fi
        else
            okay "Not an IC user"
        fi

        # Plato access => no PHI access
        if ${plato}; then
            if ${phi}; then
		if ${admin}; then
                    skip "Plato user has PHI access; ignoring because admin"
		else
                    fail "Plato user has PHI access"
		fi
            else
                okay "Plato user without PHI access"
            fi
        else
            okay "Not a Plato user"
        fi
        
        # PHI user is in 'wynton-phi', otherwise not
        if ${phi}; then
            if id "${user}" | grep -q -F "(wynton-phi)"; then
                okay "PHI user is in 'wynton-phi' group"
            else
                fail "PHI user is not in 'wynton-phi' group"
            fi
        else
            if id "${user}" | grep -q -F "(wynton-phi)"; then
                fail "Non-PHI user is in 'wynton-phi' group"
            else
                okay "Non-PHI user is not in 'wynton-phi' group"
            fi
        fi
        
        # Admin user is in 'wynton-admins', otherwise not
        if ${admin}; then
            if id "${user}" | grep -q -F "(wynton-admins)"; then
                okay "Admin user is in 'wynton-admins' group"
            else
                fail "Admin user is not in 'wynton-admins' group"
            fi
        else
            if id "${user}" | grep -q -F "(wynton-admins)"; then
                fail "Non-admin user is in 'wynton-admins' group"
            else
                okay "Non-admin user is not in 'wynton-admins' group"
            fi
        fi
        
        # No duplicated home directories
        mapfile -t res < <(ldap_search "homeDirectory=${home}" "homeDirectory" | ldap_get_field "homeDirectory")
        if [[ ${#res[@]} -gt 1 ]]; then
            fail "HOME folder is not unique: [n=${#res[@]}] ${res[*]}"
        else
            okay "HOME folder is unique"
        fi
        
        # Users has a HOME directories under expected /wynton/ location
        if ${phi}; then
            expected="/wynton/protected/home/{group}/"
        else
            expected="/wynton/home/{group}/"
        fi
        pattern="${expected/\{group\}/[[:alnum:]_.-]+}"
        if grep -q -E "^${pattern}" <<< "${home}"; then
            okay "HOME folder is under ${expected}"
        else
	    if ${admin}; then
                skip "HOME folder is not under ${expected}; ignoring because admin"
	    else
                fail "HOME folder is not under ${expected}"
	    fi
        fi
    
        if [[ ${EUID} -ne 0 ]] && ${phi} && ! ${running_as_phi}; then
            skip=true
        else
            skip=false
        fi
        if ${skip}; then
            skip "HOME folder exists"
            skip "HOME folder is owned by user"
        else
            if [[ -d "${home}" ]]; then
                okay "HOME folder exists"
                if [[ $(stat --format="%u" "${home}") == "${uid}" ]]; then
                    okay "HOME folder is owned by user"
                else
                    fail "HOME folder is not owned by user"
                fi
            else
                fail "HOME folder does not exist"
                skip "HOME folder is owned by user"
            fi
        fi

        avail=$(( beegfs_home_quota[2] / 2 ))
        if [[ ${avail} -le 0 ]]; then
            overuse=-${avail}
            if [[ ${overuse} -gt $(( 10 * 1024**3 )) ]]; then
                fail "HOME disk quota is full ($(pretty_int "$(( overuse / 1024**3 ))") GiB overuse)"
            elif [[ ${overuse} -gt $(( 10 * 1024**2 )) ]]; then
                fail "HOME disk quota is full ($(pretty_int "$(( overuse / 1024**2 ))") MiB overuse)"
            elif [[ ${overuse} -gt $(( 10 * 1024 )) ]]; then
                fail "HOME disk quota is full ($(pretty_int "$(( overuse / 1024 ))") KiB overuse)"
            else
                fail "HOME disk quota is full (${overuse} bytes overuse)"
            fi
        elif [[ ${avail} -lt $(( 10 * 1024**2 )) ]]; then
            fail "HOME disk quota has less than 10 MiB left ($(pretty_int "$(( avail / 1024 ))") KiB available)"
        elif [[ ${avail} -lt $(( 1 * 1024 ** 3 )) ]]; then
            note "HOME disk quota has less than 1.0 GiB left ($(pretty_int "$(( avail / 1024**2 ))") MiB available)"
        else
            okay "HOME disk quota has at least 1.0 GiB left"
        fi

        chunks=${beegfs_home_quota[4]}
        ## Threshold is set in https://github.com/ucsf-wynton/sysadmin-tools/blob/main/backups/get_backup_dirs.py#L16,
        ## and it is strictly less than (https://github.com/ucsf-wynton/sysadmin-tools/blob/main/backups/get_backup_dirs.py#L84)
        max_chunks=$((10 * 1000**2))
        if [[ ${chunks} -lt ${max_chunks} ]]; then
            okay "HOME is backed up - less than $(pretty_int "${max_chunks}") chunks"
        else
            note "HOME is not backed up - more than $(pretty_int "${max_chunks}") chunks"
        fi

        for kk in $(seq "${#groups[@]}"); do
                group_kk=${groups[$((kk-1))]}
            if skip_group_quota "${group_kk}"; then
                continue
            fi
                gid_kk=${gids[$((kk-1))]}
            mapfile -t quota < <(beegfs_group_quota "${gid_kk}")
            if [[ ${quota[1]} -le 0 ]]; then
                ## FIXME: RVBI groups should have unlimited quotas per
                ## https://github.com/ucsf-wynton/support/issues/1426, so
                ## for now we can only give a warning /HB 2025-01-23
                footnote "${yellow}WARNING: Group '${group_kk}' disk quota is set to 0 bytes (= unlimited); should it be 1 byte?${reset}"
            elif [[ ${quota[1]} -eq 1 ]]; then
                okay "Group '${group_kk}' disk quota not available"
            else
                if [[ ${quota[2]} -le 0 ]]; then
                    fail "Group '${group_kk}' disk quota is full ($(pretty_int "${quota[2]}") bytes available)"
                elif [[ ${quota[2]} -lt $(( 1 * 1024 ** 3 )) ]]; then
                    fail "Group '${group_kk}' disk quota has less than 1.0 GiB left ($(pretty_int "$(( quota[2] / 1024**2 ))") MiB available)"
                elif [[ ${quota[2]} -lt $(( 100 * 1024 ** 3 )) ]]; then
                    note "Group '${group_kk}' disk quota has less than 100 GiB left ($(pretty_int "$(( quota[2] / 1024**3 ))") GiB available)"
                else
                    okay "Group '${group_kk}' disk quota has at least 100 GiB left"
                fi
            fi
        done
        
        # No duplicated email addresses
        mapfile -t res < <(ldap_search "mail=${email}" "mail" | ldap_get_field "mail")
        if [[ ${#res[@]} -gt 1 ]]; then
            fail "Email address is not unique: [n=${#res[@]}] ${res[*]}"
        else
            okay "Email address is unique"
        fi
        
        # Valid email address
        if grep -q -i -E "$(email_pattern)" <<< "${email}"; then
            okay "Email address has a valid format"
        else
            fail "Email address does not have a valid format"
        fi
    
        # Valid UCSF ID
        if [[ -n "${ucsf_id}" ]]; then
            if valid_ucsf_id "${ucsf_id}"; then
                okay "UCSF Employee ID is valid"
            else
                fail "UCSF Employee ID is invalid"
            fi
    
            # No duplicated UCSF ID
            mapfile -t res < <(ldap_search "ucsfIDNumber=${ucsf_id}" "ucsfIDNumber" | ldap_get_field "ucsfIDNumber")
            if [[ ${#res[@]} -gt 1 ]]; then
                fail "UCSF Employee ID is not unique: [n=${#res[@]}] ${res[*]}"
            else
                okay "UCSF Employee ID is unique"
            fi
        else
            if is_ucsf_email "${email}"; then
                fail "UCSF Employee ID is missing"
            else
                okay "UCSF Employee ID is not required"
            fi
        fi
    
        # No locked account has access
        if ${locked}; then
            if ${access}; then
                note "Locked account still have access"
            else
                okay "Locked account does not have access"
            fi
        else
             okay "Account is not locked"
        fi
    
        # Login shell is valid
        if [[ -z ${shell} ]]; then
            fail "Login shell is not specified"
        else
            if [[ ! -f "${shell}" ]]; then
                fail "Login shell does not exist"
            elif [[ ! -x "${shell}" ]]; then
                fail "Login shell is non-executable"
            else
                okay "Login shell is an executable"
            fi
        fi
    
        # Faculty sponsor is valid
        if [[ -z ${faculty_sponsor} ]]; then
            fail "Faculty sponsor is missing"
        else
            pattern="^([[:alpha:] .'-]+)[[:blank:]]+<([^>]+)>$"
            if grep -q -i -E "${pattern}" <<< "${faculty_sponsor}"; then
                faculty_sponsor_fullname=$(sed -E "s/${pattern}/\1/" <<< "${faculty_sponsor}")
                faculty_sponsor_email=$(sed -E "s/${pattern}/\2/" <<< "${faculty_sponsor}")
                if [[ -z "${faculty_sponsor_fullname}" ]]; then
                    echo "[FAIL Faculty sponsor lacks a full name"
                elif [[ -z "${faculty_sponsor_email}" ]]; then
                    echo "[FAIL Faculty sponsor lacks an email address"
                elif ! grep -q -i -E "$(email_pattern)" <<< "${faculty_sponsor_email}"; then
                    echo "[FAIL Faculty sponsor email address is not a valid address"
                else
                    okay "Faculty sponsor has a full name and email address"
                fi
            else
                fail "Faculty sponsor does not have a full name and email address"
            fi
        fi
        
        # No mixed 'wyntonAccess'
        field="wyntonAccess"
        mapfile -t res < <(printf "%s\n" "${ldap_info[@]}" | grep -E "^${field}:")
        if [[ ${#res[@]} -gt 1 ]]; then
            fail "User has multiple LDAP '${field}' entries: [n=${#res[@]}] ${res[*]}"
        elif [[ ${#res[@]} -eq 0 ]]; then
            fail "User lacks LDAP '${field}' entry"
        else
            okay "User has unique LDAP '${field}' entry"
        fi
    
        # No mixed 'protectedAccess'
        field="protectedAccess"
        mapfile -t res < <(printf "%s\n" "${ldap_info[@]}" | grep -E "^${field}:")
        if [[ ${#res[@]} -gt 1 ]]; then
            fail "User has multiple LDAP '${field}' entries: [n=${#res[@]}] ${res[*]}"
        elif [[ ${#res[@]} -eq 0 ]]; then
            fail "User lacks LDAP '${field}' entry"
        else
            okay "User has unique LDAP '${field}' entry"
        fi

        ## Has 'wyntonProject'
        field="wyntonProject"
        mapfile -t res < <(printf "%s\n" "${ldap_info[@]}" | grep -E "^${field}:")
        if [[ ${#res[@]} -gt 1 ]]; then
            fail "User has multiple LDAP '${field}' entries: [n=${#res[@]}] ${res[*]}"
        elif [[ ${#res[@]} -eq 0 ]]; then
            fail "User lacks LDAP '${field}' entry"
        else
            okay "User has unique LDAP '${field}' entry"
        fi

        ## SGE
        if ${in_sge}; then
            okay "User is in SGE"

            if qconf -su "${sge_project}" | sed ':a;N;$!ba;s/\\\n/ /g' | grep -E "^entries " | grep -q -E "\b${user}\b"; then
                okay "User is member of SGE project"
            else
                fail "User is not member of SGE project"
            fi        
    
            if [[ ${wynton_project} == "${sge_project}" ]]; then
                okay "SGE 'default_project' and LDAP 'wyntonProject' agree"
            else
                fail "SGE 'default_project' and LDAP 'wyntonProject' do not agree"
            fi
    
            pathname="/wynton/home${SGE_ROOT}/common/sgeCA/usercerts/${user}/cert.pem"
            if [[ -f "${pathname}" ]]; then
                if check_user_cert "${user}" > /dev/null; then
                    okay "Has a valid, non-expired SGE certificate"
                else
                    fail "Has an SGE certificate that is either invalid or expired"
                fi
            else
                fail "SGE certificate is missing"
            fi
        else
            fail "User is not in SGE"
        fi
    
        echo
        echo "Summary: ${n_okay} OK, ${n_note} NOTE, ${n_fail} FAIL, ${n_skip} SKIP"    
    fi

    list_footnotes

    if ${check}; then
        if [[ ${n_fail} -gt 0 ]]; then
            echo >&2
            error "Detected ${n_fail} FAIL"
        fi
    fi    
fi
