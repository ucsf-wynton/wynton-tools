#! /usr/bin/env bash
#' Wynton Account Validation
#'
#' Usage:
#'  wynton-account [options]
#'
#' Flags:
#'  --help           Display this help
#'  --version        Display version
#'
#' Options:
#'  --user=USER      User to query by username (default: $USER)
#'
#' Examples:
#'  wynton account
#'  wynton account --user=alice
#'  wynton account --user=1000
#'
#' Version: 0.0.1
#' Copyright: Henrik Bengtsson (2024)
#' License: GPL (>= 2.1) [https://www.gnu.org/licenses/gpl.html]
call="$0 $*"

this="${BASH_SOURCE%/}"
[[ -L "${this}" ]] && this=$(readlink "${this}")

utils="$(dirname "${this}")/utils"

## Import bash utility functions
incl="$(dirname "${this}")/incl"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"
# shellcheck source=incl/system.sh
source "${incl}/system.sh"
# shellcheck source=incl/ldap.sh
source "${incl}/ldap.sh"


# -------------------------------------------------------------------------
# SPECIFIC
# -------------------------------------------------------------------------
function outcome {
    local state=${1:?}
    local -i color=${2:?}
    
    printf "%s" "["
    _tput setaf "${color}"
    printf "%s" "${state}"
    _tput sgr0    ## reset
    printf "%s" "]"
    shift
    shift
    echo " $*"
}    
    
function okay {
    outcome " OK " 2 "$@" ## green
}

function fail {
    outcome "FAIL" 1 "$@" ## red
}

function skip {
    outcome "SKIP" 8 "$@" ## gray
}



# -------------------------------------------------------------------------
# MAIN
# -------------------------------------------------------------------------
## Actions
action=validate

## Options
debug=false
verbose=false
user=${USER}

# Parse command-line options
while [[ $# -gt 0 ]]; do
    if test "$1" == "--help"; then
        action=help
    elif test "$1" == "--version"; then
        action=version
    elif test "$1" == "--debug"; then
        debug=true
    elif test "$1" == "--verbose"; then
        verbose=true

    ## Deprecated
    elif test "$1" == "--user"; then
        shift
        user=$1
        mdeprecated "Command-line option format '$1 <value>' is deprecated. Please use '$1=<value>' instead"
        
    ## Options (--key=value):
    elif [[ "$1" =~ ^--.*=.*$ ]]; then
        key=${1//--}
        key=${key//=*}
        value=${1//--[[:alpha:]]*=}
        mdebug "Key-value option '$1' parsed to key='${key}', value='${value}'"
        if [[ -z ${value} ]]; then
            error "Option '--${key}' must not be empty"
        fi
        if [[ "${key}" == "user" ]]; then
            user=${value}
	    if is_integer "${value}"; then
                user=$(uid_to_user "${value}")
	    fi
        else
            error "Unknown option: $1"
        fi
     else
        extras="$extras $1"
    fi
    shift
done

## Assert that user exists
id --user "$user" &> /dev/null || error "No such user: $user"

if [[ $user == "$USER" ]]; then
    home=$HOME
else
    home=$(getent passwd "$user" | cut -d: -f6)
fi

uid=$(id --user "$user")
gid=$(id --group "$user")
group=$(id --group --name "$user")

if $debug; then
    mdebug "call: $call"
    mdebug "action: $action"
    mdebug "verbose: $verbose"
    mdebug "user: $user"
    mdebug "group: $group"
    mdebug "uid: $uid"
    mdebug "gid: $gid"
    mdebug "home: $home"
fi

if [[ $action == "version" ]]; then
    version
    exit 0
elif [[ $action == "help" ]]; then
    help ""
    exit 0
fi

if [[ $action == "validate" ]]; then
    n_ok=0
    n_fail=0
    n_skip=0

    same_user=true
    if [[ "${user}" != "${USER}" ]]; then
        same_user=false
        warn "Running as user '${USER}' != '${user}'"
        echo >&2
    fi
    
    mapfile -t ldap_info < <(ldap_search "uid=${user}" "+" "*" | sort)
    #    printf "%s\n" "${ldap_info[@]}"
    
    # No duplicated username
    count=$(ldap_get_field "uid" "${ldap_info[@]}" | wc -l)
    if [[ ${count} -gt 1 ]]; then
        error "There are ${count} users in LDAP with username '${user}'"
    fi

    phi=false
    if [[  $(ldap_get_field "protectedAccess" "${ldap_info[@]}") == "TRUE" ]]; then
        phi=true
    fi

    if ${same_user}; then
        running_as_phi=${phi}
    else
        if [[ "$(ldap_search "uid=${USER}" "protectedAccess" | ldap_get_field "protectedAccess")" == "TRUE" ]]; then
            running_as_phi=true
        else
            running_as_phi=false
        fi
    fi
    if [[ ${running_as_phi} != "${phi}" ]]; then
        warn "Cannot run all checks on PHI user, because running as a non-PHI user"
        echo >&2
    fi
    
    access=false
    if [[  $(ldap_get_field "wyntonAccess" "${ldap_info[@]}") == "TRUE" ]]; then
        access=true
    fi

    locked=false
    if [[  $(ldap_get_field "isLocked" "${ldap_info[@]}") == "TRUE" ]]; then
        locked=true
    fi
    
    email=$(ldap_get_field "mail" "${ldap_info[@]}")
    ucsf_id=$(ldap_get_field "ucsfIDNumber" "${ldap_info[@]}")
    shell=$(ldap_get_field "loginShell" "${ldap_info[@]}")
    faculty_sponsor=$(ldap_get_field "FacultySponsor" "${ldap_info[@]}")

    
    echo "# Account Validation"
    echo
    echo "## Overview"
    echo
    echo "* User: $user (uid=$uid)"
    echo "* Group: $group (gid=$gid)"
    echo "* HOME: $home"
    echo "* Email address: ${email}"
    echo "* UCSF Employee ID: ${ucsf_id:-N/A}"
    echo "* Wynton account: ${access}"
    echo "* Locked account: ${locked}"
    echo "* PHI account: ${phi}"
    echo "* Login shell: ${shell}"
    echo "* Faculty sponsor: ${faculty_sponsor}"
    ts=$(ldap_get_field "createTimestamp" "${ldap_info[@]}")
    echo "* Account created on: $(ldap_as_timestamp "${ts}")"
    ts=$(ldap_get_field "modifyTimestamp" "${ldap_info[@]}")
    echo "* Account last-modified on: $(ldap_as_timestamp "${ts}")"
    echo
    
    echo "## Checks"
    echo
    
    okay "Username is unique"  ## validated above
    
    # No 'reserved' usernames
    mapfile -t reserved < <(reserved_usernames)
    if [[ " ${reserved[@]} " =~ " ${user} " ]]; then
        fail "Username is a 'reserved' username and should not be used"
        n_fail=$((n_fail + 1))
    else
        okay "Username is not a 'reserved' username"
        n_ok=$((n_ok + 1))
    fi

    # No duplicated UID
    mapfile -t res < <(ldap_search "uidNumber=${uid}" "uid" | ldap_get_field "uid")
    if [[ ${#res[@]} -gt 1 ]]; then
        fail "User ID (UID) is not unique: [n=${#res[@]}] ${res[*]}"
        n_fail=$((n_fail + 1))
    else
        okay "User ID (UID) is unique"
        n_ok=$((n_ok + 1))
    fi

    # UIDs within [1023,65535]
    if [[ ${uid} -lt 1023 ]] || [[ ${uid} -gt 65535 ]]; then
        fail "User ID (UID) is out of range [1023,65535]"
        n_fail=$((n_fail + 1))
    else
        okay "User ID (UID) is within [1023,65535]"
        n_ok=$((n_ok + 1))
    fi

    # GIDs within [455,65535]
    if [[ ${gid} -lt 455 ]] || [[ ${gid} -gt 65535 ]]; then
        fail "Group ID (GID) is out of range [455,65535]"
        n_fail=$((n_fail + 1))
    else
        okay "Group ID (GID) is within [415,65535]"
        n_ok=$((n_ok + 1))
    fi

    # PHI user is in 'wynton-phi', otherwise not
    if ${phi}; then
        if id "${user}" | grep -q -F "(wynton-phi)"; then
            okay "PHI user is in 'wynton-phi' group"
            n_ok=$((n_ok + 1))
        else
            fail "PHI user is not in 'wynton-phi' group"
            n_fail=$((n_fail + 1))
        fi
    else
        if id "${user}" | grep -q -F "(wynton-phi)"; then
            fail "Non-PHI user is in 'wynton-phi' group"
            n_fail=$((n_fail + 1))
        else
            okay "Non-PHI user is not in 'wynton-phi' group"
            n_ok=$((n_ok + 1))
        fi
    fi
    
    # No duplicated home directories
    mapfile -t res < <(ldap_search "homeDirectory=${home}" "homeDirectory" | ldap_get_field "homeDirectory")
    if [[ ${#res[@]} -gt 1 ]]; then
        fail "HOME folder is not unique: [n=${#res[@]}] ${res[*]}"
        n_fail=$((n_fail + 1))
    else
        okay "HOME folder is unique"
        n_ok=$((n_ok + 1))
    fi
    
    # Users has a HOME directories under expected /wynton/ location
    if ${phi}; then
        expected="/wynton/protected/home/{group}/"
    else
        expected="/wynton/home/{group}/"
    fi
    pattern=$(sed 's/{group}/[[:alnum:]_.-]+/' <<< "${expected}")
    if grep -q -E "^${pattern}" <<< "${home}"; then
        okay "HOME folder is under ${expected}"
        n_ok=$((n_ok + 1))
    else
        fail "HOME folder is not under ${expected}"
        n_fail=$((n_fail + 1))
    fi

    if [[ ${EUID} -ne 0 ]] && ${phi} && ! ${running_as_phi}; then
        skip=true
    else
        skip=false
    fi
    if ${skip}; then
        skip "HOME folder exists"
        skip "HOME folder is owned by user"
        n_skip=$((n_skip + 2))
    else
        if [[ -d "${home}" ]]; then
            okay "HOME folder exists"
            n_ok=$((n_ok + 1))
        else
            fail "HOME folder does not exist"
            n_fail=$((n_fail + 1))
        fi
        
        if [[ $(stat --format="%u" "${home}") == "${uid}" ]]; then
            okay "HOME folder is owned by user"
            n_ok=$((n_ok + 1))
        else
            fail "HOME folder is not owned by user"
            n_fail=$((n_fail + 1))
        fi
    fi

    # No duplicated email addresses
    mapfile -t res < <(ldap_search "mail=${email}" "mail" | ldap_get_field "mail")
    if [[ ${#res[@]} -gt 1 ]]; then
        fail "Email address is not unique: [n=${#res[@]}] ${res[*]}"
        n_fail=$((n_fail + 1))
    else
        okay "Email address is unique"
        n_ok=$((n_ok + 1))
    fi
    
    # Valid email address
    if grep -q -i -E "$(email_pattern)" <<< "${email}"; then
        okay "Email address has a valid format"
        n_ok=$((n_ok + 1))
    else
        fail "Email address does not have a valid format"
        n_fail=$((n_fail + 1))
    fi

    # Valid UCSF ID
    if [[ -n "${ucsf_id}" ]]; then
        if valid_ucsf_id "${ucsf_id}"; then
            okay "UCSF Employee ID is valid"
            n_ok=$((n_ok + 1))
        else
            fail "UCSF Employee ID is invalid"
            n_fail=$((n_fail + 1))
        fi

        # No duplicated UCSF ID
        mapfile -t res < <(ldap_search "ucsfIDNumber=${ucsf_id}" "ucsfIDNumber" | ldap_get_field "ucsfIDNumber")
        if [[ ${#res[@]} -gt 1 ]]; then
            fail "UCSF Employee ID is not unique: [n=${#res[@]}] ${res[*]}"
            n_fail=$((n_fail + 1))
        else
            okay "UCSF Employee ID is unique"
            n_ok=$((n_ok + 1))
        fi
    else
        if is_ucsf_email "${email}"; then
            fail "UCSF Employee ID is missing"
            n_fail=$((n_fail + 1))
        else
            okay "UCSF Employee ID is not required"
            n_skip=$((n_skip + 1))
        fi
    fi

    # No locked account has access
    if ${locked}; then
        if ${access}; then
            fail "Locked account still have access"
            n_fail=$((n_fail + 1))
        else
            okay "Locked account does not have access"
            n_fail=$((n_fail + 1))
        fi
    else
         okay "Account is not locked"
         n_skip=$((n_skip + 1))
    fi

    # Login shell is valid
    if [[ -z ${shell} ]]; then
        fail "Login shell is not specified"
        n_fail=$((n_fail + 1))
    else
        if [[ ! -f "${shell}" ]]; then
            fail "Login shell does not exist"
            n_fail=$((n_fail + 1))
        elif [[ ! -x "${shell}" ]]; then
            fail "Login shell is non-executable"
            n_fail=$((n_fail + 1))
        else
            okay "Login shell is an executable"
        fi
    fi

    # Faculty sponsor is valid
    if [[ -z ${faculty_sponsor} ]]; then
        fail "Faculty sponsor is missing"
        n_fail=$((n_fail + 1))
    else
        pattern="^([[:alpha:] .'-]+)[[:blank:]]+<([^>]+)>$"
        if grep -q -i -E "${pattern}" <<< "${faculty_sponsor}"; then
            faculty_sponsor_fullname=$(sed -E "s/${pattern}/\1/" <<< "${faculty_sponsor}")
            faculty_sponsor_email=$(sed -E "s/${pattern}/\2/" <<< "${faculty_sponsor}")
            if [[ -z "${faculty_sponsor_fullname}" ]]; then
                echo "[FAIL Faculty sponsor lacks a full name"
                n_fail=$((n_fail + 1))
            elif [[ -z "${faculty_sponsor_email}" ]]; then
                echo "[FAIL Faculty sponsor lacks an email address"
                n_fail=$((n_fail + 1))
            elif ! grep -q -i -E "$(email_pattern)" <<< "${faculty_sponsor_email}"; then
                echo "[FAIL Faculty sponsor email address is not a valid address"
            else
                okay "Faculty sponsor has a full name and email address"
                n_ok=$((n_ok + 1))
            fi
        else
            fail "Faculty sponsor does not have a full name and email address"
            n_fail=$((n_fail + 1))
        fi
    fi
    
    # No mixed 'wyntonAccess'
    mapfile -t res < <(printf "%s\n" "${ldap_info[@]}" | grep -E "^wyntonAccess:")
    if [[ ${#res[@]} -gt 1 ]]; then
        fail "User has multiple LDAP 'wyntonAccess' entries: [n=${#res[@]}] ${res[*]}"
        n_fail=$((n_fail + 1))
    else
        okay "User has unique LDAP 'wyntonAccess' entry"
        n_ok=$((n_ok + 1))
    fi

    # No mixed 'protectedAccess'
    mapfile -t res < <(printf "%s\n" "${ldap_info[@]}" | grep -E "^protectedAccess:")
    if [[ ${#res[@]} -gt 1 ]]; then
        fail "User has multiple LDAP 'protectedAccess' entries: [n=${#res[@]}] ${res[*]}"
        n_fail=$((n_fail + 1))
    else
        okay "User has unique LDAP 'protectedAccess' entry"
        n_ok=$((n_ok + 1))
    fi

    if qconf -suserl | grep -q -E "^${user}$"; then
        mapfile -t sge_info < <(qconf -suser "${user}")        
        okay "User is in SGE"
        n_ok=$((n_ok + 1))
        wynton_project=$(ldap_get_field "wyntonProject" "${ldap_info[@]}")
        sge_project=$(sge_get_field "default_project" "${sge_info[@]}")
        if [[ ${wynton_project} == "${sge_project}" ]]; then
            okay "SGE 'default_project' and LDAP 'wyntonProject' agree"
            n_ok=$((n_ok + 1))
        else
            fail "SGE 'default_project' and LDAP 'wyntonProject' do not agree"
            n_fail=$((n_fail + 1))
        fi

        pathname="/wynton/home${SGE_ROOT}/common/sgeCA/usercerts/${user}/cert.pem"
	if [[ -f "${pathname}" ]]; then
            ## Skip SGE certificates that expired when Wynton moved to "non-expiring" certs                                         
            ## "We moved to 40 year SGE certs for unexpired and new users. We did not renew already expired certs."                 
            ## https://github.com/ucsf-wynton/support/issues/1308
            since="2022-06-29 17:51:46 -0700"
            if check_user_cert "${user}" "${since}"; then
                okay "Has a valid, non-expired SGE certificate"
                n_ok=$((n_ok + 1))
	    else
                fail "Has an SGE certificate that is either invalid or expired"
                n_fail=$((n_fail + 1))
	    fi
	else
            fail "SGE certificate is missing"
	fi
    else
        fail "User is not in SGE"
        n_fail=$((n_fail + 1))
    fi
    
    echo
    echo "Summary: ${n_ok} OK, ${n_fail} FAIL, ${n_skip} SKIP"

    if [[ ${n_fail} -gt 0 ]]; then
        echo >&2
        error "Detected ${n_fail} FAIL"
    fi
fi

