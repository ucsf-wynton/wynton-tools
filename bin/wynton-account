#! /usr/bin/env bash
#' Wynton Account Information
#'
#' Looks up a Wynton user account, outputs a summary, and,
#' optionally, checks its settings.
#'
#' Usage:
#'  wynton-account [options]
#'
#' Flags:
#'  --help           Display this help
#'  --version        Display version
#'  --check          Checks the account settings
#'
#' Options:
#'  --user=<user>    User to query (default: $USER)
#'
#' Examples:
#'  wynton account
#'  wynton account --user=alice
#'  wynton account --user=alice --check
#'  wynton account --user=1000
#'  wynton account --user=alice@bobsonlab.org
#'
#' Version: 0.2.0
#' Copyright: Henrik Bengtsson (2024)
#' License: GPL (>= 2.1) [https://www.gnu.org/licenses/gpl.html]
call="$0 $*"

this="${BASH_SOURCE%/}"
[[ -L "${this}" ]] && this=$(readlink "${this}")

utils="$(dirname "${this}")/utils"

## Import bash utility functions
incl="$(dirname "${this}")/incl"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"
# shellcheck source=incl/system.sh
source "${incl}/system.sh"
# shellcheck source=incl/ldap.sh
source "${incl}/ldap.sh"


# -------------------------------------------------------------------------
# SPECIFIC
# -------------------------------------------------------------------------
function outcome {
    local state=${1:?}
    local -i color=${2:?}
    
    printf "%s" "["
    _tput setaf "${color}"
    printf "%s" "${state}"
    _tput sgr0    ## reset
    printf "%s" "]"
    shift
    shift
    echo " $*"
}    

n_okay=0
function okay {
    outcome " OK " 2 "$@" ## green
    n_okay=$((n_okay + 1))
}

n_fail=0
function fail {
    outcome "FAIL" 1 "$@" ## red
    n_fail=$((n_fail + 1))
}

n_note=0
function note {
    outcome "NOTE" 3 "$@" ## yellow
    n_note=$((n_note + 1))
}

n_skip=0
function skip {
    outcome "SKIP" 8 "$@" ## gray
    n_skip=$((n_skip + 1))
}


# -------------------------------------------------------------------------
# MAIN
# -------------------------------------------------------------------------
## Actions
action=validate

## Options
check=false
debug=false
user=${USER}

# Parse command-line options
while [[ $# -gt 0 ]]; do
    if test "$1" == "--help"; then
        action=help
    elif test "$1" == "--version"; then
        action=version
    elif test "$1" == "--debug"; then
        debug=true
    elif test "$1" == "--check"; then
        check=true

    ## Deprecated
    elif test "$1" == "--user"; then
        shift
        user=$1
        mdeprecated "Command-line option format '$1 <value>' is deprecated. Please use '$1=<value>' instead"
        
    ## Options (--key=value):
    elif [[ "$1" =~ ^--.*=.*$ ]]; then
        key=${1//--}
        key=${key//=*}
        value=${1//--[[:alpha:]]*=}
        mdebug "Key-value option '$1' parsed to key='${key}', value='${value}'"
        if [[ -z ${value} ]]; then
            error "Option '--${key}' must not be empty"
        fi
        if [[ "${key}" == "user" ]]; then
            user=${value}
            if is_integer "${value}"; then
                user=$(uid_to_user "${value}")
            elif is_email "${value}"; then
                mapfile -t users < <(email_to_user "${value}")
                if [[ ${#users[@]} -eq 0 ]]; then
                        error "There is no user with email address ${email}"
                elif [[ ${#users[@]} -gt 1 ]]; then
                        error "There are more than one user with email address ${value}: [n=${#users[@]}] ${users[*]}"
                fi
                user=${users[0]}
            fi
        else
            error "Unknown option: $1"
        fi
     else
        extras="$extras $1"
    fi
    shift
done

## Assert that user exists
id --user "$user" &> /dev/null || error "No such user: $user"

if [[ $user == "$USER" ]]; then
    home=$HOME
else
    home=$(getent passwd "$user" | cut -d: -f6)
fi

uid=$(id --user "$user")
gid=$(id --group "$user")
group=$(id --group --name "$user")

if $debug; then
    mdebug "call: $call"
    mdebug "action: $action"
    mdebug "check: $check"
    mdebug "user: $user"
    mdebug "group: $group"
    mdebug "uid: $uid"
    mdebug "gid: $gid"
    mdebug "home: $home"
fi

if [[ $action == "version" ]]; then
    version
    exit 0
elif [[ $action == "help" ]]; then
    help ""
    exit 0
fi

if [[ $action == "validate" ]]; then
    n_okay=0
    n_note=0
    n_fail=0
    n_skip=0

    same_user=true
    if [[ "${user}" != "${USER}" ]]; then
        same_user=false
        warn "Running as user '${USER}' != '${user}'"
        echo >&2
    fi
    
    mapfile -t ldap_info < <(ldap_search "uid=${user}" "+" "*" | sort)
    #    printf "%s\n" "${ldap_info[@]}"
    
    # No duplicated username
    count=$(ldap_get_field "uid" "${ldap_info[@]}" | wc -l)
    if [[ ${count} -gt 1 ]]; then
        error "There are ${count} users in LDAP with username '${user}'"
    fi

    ## Access to PHI?
    phi=false
    if [[  $(ldap_get_field "protectedAccess" "${ldap_info[@]}") == "TRUE" ]]; then
        phi=true
    fi

    if ${same_user}; then
        running_as_phi=${phi}
    else
        if [[ "$(ldap_search "uid=${USER}" "protectedAccess" | ldap_get_field "protectedAccess")" == "TRUE" ]]; then
            running_as_phi=true
        else
            running_as_phi=false
        fi
    fi
    if [[ ${running_as_phi} != "${phi}" ]]; then
        warn "Cannot run all checks on PHI user, because running as a non-PHI user"
        echo >&2
    fi
    
    ## Access to Wynton?
    access=false
    if [[  $(ldap_get_field "wyntonAccess" "${ldap_info[@]}") == "TRUE" ]]; then
        access=true
    fi

    ## Is account locked?
    locked=false
    if [[  $(ldap_get_field "isLocked" "${ldap_info[@]}") == "TRUE" ]]; then
        locked=true
    fi
    
    email=$(ldap_get_field "mail" "${ldap_info[@]}")
    ucsf_id=$(ldap_get_field "ucsfIDNumber" "${ldap_info[@]}" | grep -i -v -E "^(none)$")
    shell=$(ldap_get_field "loginShell" "${ldap_info[@]}")
    faculty_sponsor=$(ldap_get_field "FacultySponsor" "${ldap_info[@]}")
    wynton_project=$(ldap_get_field "wyntonProject" "${ldap_info[@]}")

    ## Access to Information Commons, i.e. an "IC user"?
    if id "${user}" | grep -q -F "(icusers)"; then
        ic=true
    else
        ic=false
    fi

    ## Access to Plato, i.e. a "Plato account"?
    plato=false
    if [[  $(ldap_get_field "platoAccess" "${ldap_info[@]}") == "TRUE" ]]; then
        plato=true
    fi

    ## SGE information
    if qconf -suserl | grep -q -E "^${user}$"; then
        in_sge=true
        mapfile -t sge_info < <(qconf -suser "${user}" | sort)
        sge_project=$(printf "%s\n" "${sge_info[@]}" | grep -E "^default_project" | sed -E 's/^default_project[[:space:]]+//')
    else
        in_sge=false
        sge_info=()
        sge_project=
    fi


    # Disk quota
    beegfs_home_storagepool=11
    mapfile -t beegfs_quota < <(beegfs-ctl --getquota --csv --storagepoolid="${beegfs_home_storagepool}" --uid "${uid}" | awk -F "," 'NR > 1 {
        used=$3
        max=$4
        if (used ~ /[^0-9]/) used = -1
        if (max ~ /[^0-9]/) max = -1
        printf "%d\n%d\n%d\n%.1f\n", used, max, max-used, 100*used/max
    }')

    
    echo "# Account Information"
    echo
    echo "## Overview"
    echo
    echo "* Full name: $(ldap_get_field "cn" "${ldap_info[@]}")"
    echo "* User: $user (uid=$uid)"
    echo "* Group: $group (gid=$gid)"
    echo "* Email address: ${email}"
    echo "* UCSF Employee ID: ${ucsf_id:-N/A}"
    echo "* Faculty sponsor: ${faculty_sponsor}"
    echo "* HOME: $home"
    echo "* HOME disk quota: $(( beegfs_quota[0] / 1024**3 / 2 )) GiB used out of $(( beegfs_quota[1] / 1024**3 / 2 )) GiB (${beegfs_quota[3]}%)"
    echo "* Wynton access: ${access}"
    echo "* PHI access: ${phi}"
    echo "* IC access: ${ic}"
    echo "* Plato access: ${plato}"
    echo "* Locked account: ${locked}"
    echo "* Login shell: ${shell}"
    echo "* Wynton project: ${wynton_project}"
    echo "* SGE project: ${sge_project}"
    
    ts=$(ldap_get_field "createTimestamp" "${ldap_info[@]}")
    echo "* Account created on: $(ldap_as_timestamp "${ts}")"
    ts=$(ldap_get_field "modifyTimestamp" "${ldap_info[@]}")
    echo "* Account last-modified on: $(ldap_as_timestamp "${ts}")"
    echo

    if ${check}; then
        echo "## Checks"
        echo
    
        okay "Username is unique"  ## validated above
        
        # No 'reserved' usernames
        mapfile -t reserved < <(reserved_usernames)
        if [[ " ${reserved[*]} " =~ [[:space:]]${user}[[:space:]] ]]; then
            fail "Username is a 'reserved' username and should not be used"
        else
            okay "Username is not a 'reserved' username"
        fi
    
        # No duplicated UID
        mapfile -t res < <(ldap_search "uidNumber=${uid}" "uid" | ldap_get_field "uid")
        if [[ ${#res[@]} -gt 1 ]]; then
            fail "User ID (UID) is not unique: [n=${#res[@]}] ${res[*]}"
        else
            okay "User ID (UID) is unique"
        fi
    
        # UIDs within [1023,65535]
        if [[ ${uid} -lt 1023 ]] || [[ ${uid} -gt 65535 ]]; then
            fail "User ID (UID) is out of range [1023,65535]"
        else
            okay "User ID (UID) is within [1023,65535]"
        fi
    
        # GIDs within [455,65535]
        if [[ ${gid} -lt 455 ]] || [[ ${gid} -gt 65535 ]]; then
            fail "Group ID (GID) is out of range [455,65535]"
        else
            okay "Group ID (GID) is within [415,65535]"
        fi
    
        # IC access => PHI access
        if ${ic}; then
            if ${phi}; then
                okay "IC user has PHI access"
            else
                fail "IC user without PHI access"
            fi
        else
            okay "Not an IC user"
        fi

        # Plato access => no PHI access
        if ${plato}; then
            if ${phi}; then
                fail "Plato user has PHI access"
            else
                okay "Plato user without PHI access"
            fi
        else
            okay "Not a Plato user"
        fi
	
        # PHI user is in 'wynton-phi', otherwise not
        if ${phi}; then
            if id "${user}" | grep -q -F "(wynton-phi)"; then
                okay "PHI user is in 'wynton-phi' group"
            else
                fail "PHI user is not in 'wynton-phi' group"
            fi
        else
            if id "${user}" | grep -q -F "(wynton-phi)"; then
                fail "Non-PHI user is in 'wynton-phi' group"
            else
                okay "Non-PHI user is not in 'wynton-phi' group"
            fi
        fi
        
        # No duplicated home directories
        mapfile -t res < <(ldap_search "homeDirectory=${home}" "homeDirectory" | ldap_get_field "homeDirectory")
        if [[ ${#res[@]} -gt 1 ]]; then
            fail "HOME folder is not unique: [n=${#res[@]}] ${res[*]}"
        else
            okay "HOME folder is unique"
        fi
        
        # Users has a HOME directories under expected /wynton/ location
        if ${phi}; then
            expected="/wynton/protected/home/{group}/"
        else
            expected="/wynton/home/{group}/"
        fi
        pattern="${expected/\{group\}/[[:alnum:]_.-]+}"
        if grep -q -E "^${pattern}" <<< "${home}"; then
            okay "HOME folder is under ${expected}"
        else
            fail "HOME folder is not under ${expected}"
        fi
    
        if [[ ${EUID} -ne 0 ]] && ${phi} && ! ${running_as_phi}; then
            skip=true
        else
            skip=false
        fi
        if ${skip}; then
            skip "HOME folder exists"
            skip "HOME folder is owned by user"
        else
            if [[ -d "${home}" ]]; then
                okay "HOME folder exists"
            else
                fail "HOME folder does not exist"
            fi
            
            if [[ $(stat --format="%u" "${home}") == "${uid}" ]]; then
                okay "HOME folder is owned by user"
            else
                fail "HOME folder is not owned by user"
            fi
        fi
    
        if [[ ${beegfs_quota[2]} -le 0 ]]; then
            fail "HOME disk quota is full (${beegfs_quota[2]} bytes available)"
        elif [[ ${beegfs_quota[2]} -lt $(( 10 * 1024**2 )) ]]; then
            fail "HOME disk quota has less than 10 MiB left ($(( beegfs_quota[2] / 1024 )) KiB available)"
        elif [[ ${beegfs_quota[2]} -lt $(( 1 * 1024 ** 3 )) ]]; then
            note "HOME disk quota has less than 1.0 GiB left ($(( beegfs_quota[2] / 1024**2 )) MiB available)"
        else
            okay "HOME disk quota has at least 1.0 GiB left"
        fi
            
        # No duplicated email addresses
        mapfile -t res < <(ldap_search "mail=${email}" "mail" | ldap_get_field "mail")
        if [[ ${#res[@]} -gt 1 ]]; then
            fail "Email address is not unique: [n=${#res[@]}] ${res[*]}"
        else
            okay "Email address is unique"
        fi
        
        # Valid email address
        if grep -q -i -E "$(email_pattern)" <<< "${email}"; then
            okay "Email address has a valid format"
        else
            fail "Email address does not have a valid format"
        fi
    
        # Valid UCSF ID
        if [[ -n "${ucsf_id}" ]]; then
            if valid_ucsf_id "${ucsf_id}"; then
                okay "UCSF Employee ID is valid"
            else
                fail "UCSF Employee ID is invalid"
            fi
    
            # No duplicated UCSF ID
            mapfile -t res < <(ldap_search "ucsfIDNumber=${ucsf_id}" "ucsfIDNumber" | ldap_get_field "ucsfIDNumber")
            if [[ ${#res[@]} -gt 1 ]]; then
                fail "UCSF Employee ID is not unique: [n=${#res[@]}] ${res[*]}"
            else
                okay "UCSF Employee ID is unique"
            fi
        else
            if is_ucsf_email "${email}"; then
                fail "UCSF Employee ID is missing"
            else
                okay "UCSF Employee ID is not required"
            fi
        fi
    
        # No locked account has access
        if ${locked}; then
            if ${access}; then
                note "Locked account still have access"
            else
                okay "Locked account does not have access"
            fi
        else
             okay "Account is not locked"
        fi
    
        # Login shell is valid
        if [[ -z ${shell} ]]; then
            fail "Login shell is not specified"
        else
            if [[ ! -f "${shell}" ]]; then
                fail "Login shell does not exist"
            elif [[ ! -x "${shell}" ]]; then
                fail "Login shell is non-executable"
            else
                okay "Login shell is an executable"
            fi
        fi
    
        # Faculty sponsor is valid
        if [[ -z ${faculty_sponsor} ]]; then
            fail "Faculty sponsor is missing"
        else
            pattern="^([[:alpha:] .'-]+)[[:blank:]]+<([^>]+)>$"
            if grep -q -i -E "${pattern}" <<< "${faculty_sponsor}"; then
                faculty_sponsor_fullname=$(sed -E "s/${pattern}/\1/" <<< "${faculty_sponsor}")
                faculty_sponsor_email=$(sed -E "s/${pattern}/\2/" <<< "${faculty_sponsor}")
                if [[ -z "${faculty_sponsor_fullname}" ]]; then
                    echo "[FAIL Faculty sponsor lacks a full name"
                elif [[ -z "${faculty_sponsor_email}" ]]; then
                    echo "[FAIL Faculty sponsor lacks an email address"
                elif ! grep -q -i -E "$(email_pattern)" <<< "${faculty_sponsor_email}"; then
                    echo "[FAIL Faculty sponsor email address is not a valid address"
                else
                    okay "Faculty sponsor has a full name and email address"
                fi
            else
                fail "Faculty sponsor does not have a full name and email address"
            fi
        fi
        
        # No mixed 'wyntonAccess'
        mapfile -t res < <(printf "%s\n" "${ldap_info[@]}" | grep -E "^wyntonAccess:")
        if [[ ${#res[@]} -gt 1 ]]; then
            fail "User has multiple LDAP 'wyntonAccess' entries: [n=${#res[@]}] ${res[*]}"
        else
            okay "User has unique LDAP 'wyntonAccess' entry"
        fi
    
        # No mixed 'protectedAccess'
        mapfile -t res < <(printf "%s\n" "${ldap_info[@]}" | grep -E "^protectedAccess:")
        if [[ ${#res[@]} -gt 1 ]]; then
            fail "User has multiple LDAP 'protectedAccess' entries: [n=${#res[@]}] ${res[*]}"
        else
            okay "User has unique LDAP 'protectedAccess' entry"
        fi
    
        if ${in_sge}; then
            okay "User is in SGE"
            if [[ ${wynton_project} == "${sge_project}" ]]; then
                okay "SGE 'default_project' and LDAP 'wyntonProject' agree"
            else
                fail "SGE 'default_project' and LDAP 'wyntonProject' do not agree"
            fi
    
            pathname="/wynton/home${SGE_ROOT}/common/sgeCA/usercerts/${user}/cert.pem"
        if [[ -f "${pathname}" ]]; then
                ## Skip SGE certificates that expired when Wynton moved to "non-expiring" certs                                         
                ## "We moved to 40 year SGE certs for unexpired and new users. We did not renew already expired certs."                 
                ## https://github.com/ucsf-wynton/support/issues/1308
                since="2022-06-29 17:51:46 -0700"
                if check_user_cert "${user}" "${since}"; then
                    okay "Has a valid, non-expired SGE certificate"
            else
                    fail "Has an SGE certificate that is either invalid or expired"
            fi
        else
                fail "SGE certificate is missing"
        fi
        else
            fail "User is not in SGE"
        fi
    
        echo
        echo "Summary: ${n_okay} OK, ${n_note} NOTE, ${n_fail} FAIL, ${n_skip} SKIP"
    
        if [[ ${n_fail} -gt 0 ]]; then
            echo >&2
            error "Detected ${n_fail} FAIL"
        fi
    fi
fi
