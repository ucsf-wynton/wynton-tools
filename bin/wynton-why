#! /usr/bin/env bash
#' Wynton Troubleshooting
#'
#' Usage:
#'  wynton-why [options]
#'
#' Options:
#'  --user USER      Query another user (default: $USER)
#'  --help           Display this help
#'  --version        Display version
#'
#' Examples:
#'  wynton why
#'  wynton why --user alice
#'
#' Version: 0.0.1-9001
#' Copyright: Henrik Bengtsson (2024)
#' License: GPL (>= 2.1) [https://www.gnu.org/licenses/gpl.html]
call="$0 $*"

this="${BASH_SOURCE%/}"
[[ -L "${this}" ]] && this=$(readlink "${this}")

## Import bash utility functions
incl="$(dirname "${this}")/incl"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"
# shellcheck source=incl/system.sh
source "${incl}/system.sh"
# shellcheck source=incl/sge.sh
source "${incl}/sge.sh"


# -------------------------------------------------------------------------
# SPECIFIC
# -------------------------------------------------------------------------


# -------------------------------------------------------------------------
# MAIN
# -------------------------------------------------------------------------
## Actions
action=why

## Options
debug=false
verbose=false
user=${USER}

# Parse command-line options
while [[ $# -gt 0 ]]; do
    if test "$1" == "--help"; then
        action=help
    elif test "$1" == "--user"; then
        shift
        user=$1
    elif test "$1" == "--version"; then
        action=version
    elif test "$1" == "--debug"; then
        debug=true
    elif test "$1" == "--verbose"; then
        verbose=true
    else
        extras="$extras $1"
    fi
    shift
done

## Assert that user exists
id --user "$user" &> /dev/null || error "No such user: $user"


if [[ $user == "$USER" ]]; then
    home=$HOME
else
    home=$(getent passwd "$user" | cut -d: -f6)
fi

uid=$(id --user "$user")
gid=$(id --group "$user")
group=$(id --group --name "$user")
downtime=$(sge_downtime_start)

if $debug; then
    mdebug "call: $call"
    mdebug "action: $action"
    mdebug "verbose: $verbose"
    mdebug "user: $user"
    mdebug "group: $group"
    mdebug "uid: $uid"
    mdebug "gid: $gid"
    mdebug "home: $home"
    mdebug "downtime: $(date --iso-8601=seconds -d "${downtime}")"
fi

if [[ $action == "version" ]]; then
    version
    exit 0
elif [[ $action == "help" ]]; then
    help 
    exit 0
fi

if [[ $action == "why" ]]; then
    echo "# Troubleshooting"
    echo
    echo "* User: $user (uid=$uid)"
    echo "Group: $group (gid=$gid)"
    echo "HOME: $home"
    echo "Working directory: ${PWD}"
    echo "Hostname: ${HOSTNAME}"

    downtime_iso=$(date_iso "${downtime}")
    when=$(date +%s -d "${downtime}")
    now=$(date +%s)
    diff=$((when - now))
    if [[ ${diff} -gt 0 ]]; then
       echo "Detected scheduled downtime: ${downtime_iso} (in ~$((diff / 3600)) hours)"
    fi
    
    echo
    echo "## Analyzing queued jobs"
    mapfile -t jobs < <(qstat -u "${user}" | grep -E "\bqw\b" | cut -d ' ' -f 1)
    echo "Queued jobs: [n=${#jobs[@]}] ${jobs[*]}"

    if [[ ${#jobs[@]} -gt 0 ]] && [[ ${diff} -gt 0 ]] && [[ ${diff} -lt $((14 * 24 * 60 * 60)) ]]; then
        info=()
        for job in "${jobs[@]}"; do
            mapfile -t bfr < <(qstat -j "${job}")
            h_rt=$(printf "%s\n" "${bfr[@]}" | grep -E ".*\bh_rt=([[:digit:]]+).*" | sed -E 's/.*\bh_rt=([[:digit:]]+).*/\1/')
            if [[ -n "${h_rt}" ]] && [[ ${h_rt} -gt ${diff} ]]; then
		name=$(printf "%s\n" "${bfr[@]}" | grep -E "^job_name:[[:blank:]]+" | sed -E 's/^job_name:[[:blank:]]+//')
		when_str=$(printf "%s\n" "${bfr[@]}" | grep -E "^submission_time:[[:blank:]]+" | sed -E 's/^submission_time:[[:blank:]]+//')
		when=$(date_iso "${when_str}")
                info+=("Job ${job} [${when}; -l h_rt=${h_rt}; name='${name}']")
            fi
        done
        if [[ ${#info[@]} -gt 0 ]]; then
            echo "WARNING: Jobs that will launch only after the scheduled downtime on ${downtime_iso}: [n=${#info[@]}]"
            printf -- "* %s\n" "${info[@]}"
        else
            echo "OK: All queued jobs have a chance to launch before the scheduled downtime on ${downtime_iso}"
        fi
    fi
    
    echo
    echo "## Analyzing kernel messages" 
    mapfile -t bfr < <(dmesg --kernel --time-format "iso")

    ## Look for OOM kills
    mapfile -t bfr2 < <(printf "%s\n" "${bfr[@]}" | grep -E "\boom-kill:.*uid=${uid}")
    if [[ ${#bfr2[@]} -gt 0 ]]; then
        info=()
        for kk in $(seq "${#bfr2[@]}"); do
            bfr_kk=${bfr2[$((kk - 1))]}
            when=$(cut -d ' ' -f 1 <<< "${bfr_kk}" | sed 's/,.*//')
            task=$(sed -E 's/.*task=([^,]+),.*/\1/' <<< "${bfr_kk}")
            pid=$(sed -E 's/.*pid=([[:digit:]]+),.*/\1/' <<< "${bfr_kk}")
            info+=("${task} [pid=$(printf "%8d" "${pid}"); when=${when}]")
        done
        if [[ ${#info[@]} -gt 0 ]]; then
            echo "WARNING: Number of recent out-of-memory (OOM) kills: [n=${#info[@]}]"
            printf -- "* %s\n" "${info[@]}" | sort -k 5
        fi
    else
        echo "OK: No recent out-of-memory (OOM) kills detected"
    fi
fi
