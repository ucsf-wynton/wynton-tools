#! /usr/bin/env bash
#' Wynton HPC Job Details
#'
#' Usage:
#'  wynton-job [options] <job_id>
#'
#' Flags:
#'  --help           Display this help
#'  --version        Display version
#'
#' Examples:
#'  wynton job --list
#'  wynton job --list-finished
#'  wynton job 4214696
#'
#' Version: 0.1.2
#' Copyright: Henrik Bengtsson (2020-2024)
#' License: GPL (>= 2.1) [https://www.gnu.org/licenses/gpl.html]
call="$0 $*"

this="${BASH_SOURCE%/}"
[[ -L "${this}" ]] && this=$(readlink "${this}")

## Import bash utility functions
incl="$(dirname "${this}")/incl"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"
# shellcheck source=incl/system.sh
source "${incl}/system.sh"
# shellcheck source=incl/sge.sh
source "${incl}/sge.sh"


# -------------------------------------------------------------------------
# CORE
# -------------------------------------------------------------------------
function ok() {
    echo "[ OK ]"
}

function fail() {
    echo "[FAIL]"
}


reformat_date() {
    sed -E "s,([[:digit:]]{2})/([[:digit:]]{2})/([[:digit:]]{4}),\3-\1-\2,g"
}

# -------------------------------------------------------------------------
# SPECIFIC
# -------------------------------------------------------------------------

## Enable terminal colors, if supported
term_colors enable

ok="${green}OK${reset}"
warn="${yellow}WARN${reset}"
fail="${red}FAIL${reset}"
na="${magenta}??${reset}"


# Outputs: (bytes, kB, MB, GB, KiB, MiB, GiB)
# shellcheck disable=2034
SIZES_INPUT=0
# shellcheck disable=2034
SIZES_B=1
# shellcheck disable=2034
SIZES_kB=2
# shellcheck disable=2034
SIZES_MB=3
# shellcheck disable=2034
SIZES_GB=4
# shellcheck disable=2034
SIZES_KiB=5
# shellcheck disable=2034
SIZES_MiB=6
# shellcheck disable=2034
SIZES_GiB=7

parse_size_spec() {
    local bytes_str
    local bytes kB MB GB KiB MiB GiB
    
    bytes_str=${1:?}

    ## Convert to IEC units to SI units
    bytes_str=${bytes_str//G/*1024M}
    bytes_str=${bytes_str//M/*1024K}
    bytes_str=${bytes_str//K/*1024}

    ## Bytes
    bytes=$(bc <<< "${bytes_str}")

    ## Sizes in SI units
    kB=$(bc <<< "scale=1; ${bytes} / 1000")
    MB=$(bc <<< "scale=1; ${kB} / 1000")
    GB=$(bc <<< "scale=1; ${MB} / 1000")
    
    ## Sizes in IEC units
    KiB=$(bc <<< "scale=1; ${bytes} / 1024")
    MiB=$(bc <<< "scale=1; ${KiB} / 1024")
    GiB=$(bc <<< "scale=1; ${MiB} / 1024")

    echo "${1}"
    echo "${bytes}"
    echo "${kB}"
    echo "${MB}"
    echo "${GB}"
    echo "${KiB}"
    echo "${MiB}"
    echo "${GiB}"
}

# -------------------------------------------------------------------------
# MAIN
# -------------------------------------------------------------------------
## Actions
action=job

## Options
debug=false
verbose=false
jobid=
user=${USER}
tail_size=1000000

# Parse command-line options
while [[ $# -gt 0 ]]; do
    if [[ "$1" == "--help" ]]; then
        action=help
    elif [[ "$1" == "--version" ]]; then
        action=version
    elif [[ "$1" == "--debug" ]]; then
        debug=true
    elif [[ "$1" == "--verbose" ]]; then
        verbose=true
	
    ## Flags (--flag):
    elif [[ "$1" == "--list" ]]; then
	action=list
    elif [[ "$1" == "--list-finished" ]]; then
	action=list-finished
	
    ## Options (--key=value):
    elif [[ "$1" =~ ^--.*=.*$ ]]; then
        key=${1//--}
        key=${key//=*}
        value=${1//--[[:alpha:]]*=}
        if [[ -z ${value} ]]; then
            error "Option '--${key}=<value>' must not be empty"
        fi
        if [[ "${key}" == "user" ]]; then
            user="${value}"
        elif [[ "${key}" == "tail" ]]; then
            assert_integer "${value}"
            tail_size="${value}"
        else
            error "Unknown option: $1"
        fi
    else
        if [[ -z $jobid ]]; then
            jobid=$1
        else
            extras="$extras $1"
        fi
    fi
    shift
done

if $debug; then
    mdebug "call: $call"
    mdebug "action: $action"
    mdebug "verbose: $verbose"
    mdebug "user: $user"
    mdebug "jobid: $jobid"
    mdebug "sge_accounting: $sge_accounting"
fi

## Assert that the job ID is numeric, if specified
[[ -z $jobid ]] || [[ $jobid =~ ^[0-9]+$ ]] || error "Non-numeric job ID: $jobid"
[[ -z $sge_accounting ]] || assert_file_exists "$sge_accounting"

## Assert that the job ID is numeric, if specified
[[ -z $jobid ]] || [[ $jobid =~ ^[0-9]+$ ]] || error "Non-numeric job ID: $jobid"


if [[ $action == "version" ]]; then
    version
    exit 0
elif [[ $action == "help" ]]; then
    help "full"
    exit 0
fi


if [[ $action == "list" ]]; then
    mapfile -t lines < <(qstat -s az -u "${user}")
    printf "%s\n" "${lines[@]}" | annotate_qstat | reformat_date
    if grep -q -E "\bE?qw\b" <<< "${lines[*]}"; then
	echo
        E="${red}E${reset}"
        q="${yellow}q${reset}"
        w="${yellow}w${reset}"
        z="${magenta}z${reset}"
	echo "Legend: ${E}=Error, ${q}=queued, ${w}=waiting, ${z}=recently finished (\"zombie\")"
	echo
	echo "Suggestions:"
	echo "wynton job <job-ID>   : details on a job"
	echo "qdel <job-ID>         : delete a job"
	echo "qdel -f <job-ID>      : try harder to delete a job"
	echo
    fi	
    exit 0
fi

if [[ $action == "list-finished" ]]; then
    bfr=$(accounting_list_finished "${user}" "${tail_size}")
    res=$?
    if [[ $res -eq 0 ]]; then
	echo "$bfr"
	exit 0
    fi
    error "Failed to locate past jobs from the last ${tail_size} records in the SGE accounting file"
fi

if [[ $action == "job" ]]; then
    [[ -z $jobid ]] && error "Job ID not specified"
    
    ## An active job?
    bfr=$(qstat -j "$jobid" 2> /dev/null)
    if [[ -n ${bfr} ]]; then
        ## Keep key: value lines
        vars=$(grep -E "^[^:]+:.*" <<< "$bfr")
        ## Fix keys
        vars=$(sed ':loop; s/^\([^:]*\) \+\([^:]*:\)/\1_\2/; t loop' <<< "$vars" | sed ':loop; s/^\([^:]*\)-\+\([^:]*:\)/\1_\2/; t loop' | sed -E 's/__+/_/g')
        ## Turn into _THIS_JOB_keys="value"
        vars=$(sed -E 's/^([^:]+):[[:space:]]*(.*)/_THIS_JOB_\1="\2"/' <<< "$vars")

        ## Parse as environment variables
        while IFS= read -r line; do
            eval "export $line"
        done <<< "$vars"
	if $debug; then
            env | grep -F "_THIS_JOB_" | sort
	fi

        ## Get additional info on the job
        # shellcheck disable=2154
        bfr2=$(qstat -s az -u "${_THIS_JOB_owner}" | grep -E "^[[:space:]]*\b${_THIS_JOB_job_number}\b[[:space:]]")
	
        ## Summarize
        ruler "-"
        echo "Job Details"
        ruler "-"
        echo

        # shellcheck disable=2154
        value=${_THIS_JOB_job_number}
        echo "[ $ok ] Job ID: ${value}"

        # shellcheck disable=2154
        value=${_THIS_JOB_job_name}
        echo "[ $ok ] Job name: ${value}"

        ## Current status
        mapfile -t values < <(awk '{ print $5 }' <<< "$bfr2")
	ntasks=${#values[@]}
        mapfile -t values < <(printf "%s\n" "${values[@]}" | uniq -c | sort -k 2 | sed -E 's/^ +//' | sed 's/ /*/')
        level=0
	values1=()
        values2=()
        for kk in "${!values[@]}"; do
            value=${values[$((kk - 1))]}
	    
	    ## Empty
	    if [[ -z ${value} ]]; then
		continue
	    fi
	
            values1+=("$value")

            value=${value/d/_00}
            value=${value/E/_01}
            value=${value/h/_02}
            value=${value/q/_03}
            value=${value/r/_04}
            value=${value/R/_05}
            value=${value/s/_0S}
            value=${value/S/_06}
            value=${value/t/_07}
            value=${value/T/_08}
            value=${value/w/_09}
            value=${value/z/_10}

            value=${value/_00/${yellow}deletion${reset} }
            value=${value/_01/${red}error${reset} }
            value=${value/_02/${yellow}hold${reset} }
            value=${value/_03/${yellow}queued${reset} }
            value=${value/_04/${green}running${reset} }
            value=${value/_05/${blue}restarted${reset} }
            value=${value/_06/${yellow}suspended${reset} }
            value=${value/_07/${blue}transfering${reset} }
            value=${value/_08/${yellow}threshold${reset} }
            value=${value/_09/${blue}waiting${reset} }
            value=${value/_10/${magenta}recently finished (\"zombie\")${reset} [${yellow}check again soon${reset}] }

            if [[ $level -lt 2 ]]; then
                if [[ $value == *error* ]]; then
                    level=3
                elif [[ $value == *zombie* ]]; then
                    level=1
                fi
            fi

            if [[ $level -lt 1 ]]; then
                if [[ $value == *deletion* ]]; then
                    level=2
                elif [[ $value == *hold* ]]; then
                    level=2
                elif [[ $value == *queued* ]]; then
                    level=2
                elif [[ $value == *threshold* ]]; then
                    level=2
                fi
            fi
            values2+=("${value/[*]/ * }")
        done

        status="[ $ok ]"
        if [[ $level == 1 ]]; then
            status="[ $na ]"
        elif [[ $level == 2 ]]; then
            status="[$warn]"
        elif [[ $level == 3 ]]; then
            status="[$fail]"
        fi
	if [[ ${#values1[@]} -gt 0 ]]; then
	    old_IFS=${IFS}
	    IFS=", "
            echo "$status Job status: [ntasks=${ntasks}] ${values1[*]} => ${values2[*]}" | sed -E 's/,/, /g' | sed -E 's/ ,/,/g'
	    IFS="${old_IFS}"
	else
            status="[ $na ]"
            echo "$status Job status: N/A"
	fi

        # shellcheck disable=2154
        value=${_THIS_JOB_owner}
        is_owner=true
        status="[ $ok ]"
        info=""
        if [[ $value != "$USER" ]]; then
            is_owner=false
            status="[$warn]"
            info=" ${yellow}WARNING: You ($USER) are not the owner of this job${reset}"
        fi
        # shellcheck disable=2154
        echo "$status Job owner: ${value} (${_THIS_JOB_uid}) of group ${_THIS_JOB_group} (${_THIS_JOB_gid}) ${info}"

        # shellcheck disable=2154
        value=${_THIS_JOB_submission_time}
        status="[ $ok ]"
        info=""
        epoch=$(date -d "${value}" '+%s' 2> /dev/null)
        timestamp=$(date -d "@${epoch}" '+%A %Y-%m-%dT%H:%M:%S%z' 2> /dev/null)
	    epoch_now=$(date "+%s")
	    delta=$(( epoch_now - epoch ))
        info="$(seconds_to_dhms "${delta}") ago"
        if [[ $delta -gt $(( 24 * 60 * 60 )) ]]; then
            info="${red}${info}${reset}"
            status="[$warn]"
        elif [[ $delta -gt $(( 6 * 60 * 60 )) ]]; then
            info="${yellow}${info}${reset}"
            status="[$warn]"
        fi
        info=" [${info}]"
        echo "$status Submitted on: ${timestamp}${info}"

        # shellcheck disable=2154
        value=${_THIS_JOB_project}
        status="[ $ok ]"
        info=""
        echo "$status Project: ${value}"
	
        # shellcheck disable=2154
        value=${_THIS_JOB_hard_queue_list}
        status="[ $ok ]"
        info=""
        echo "$status Job queue: ${value}"

        # shellcheck disable=2154
        value=${_THIS_JOB_hard_resource_list}

        is_rocky8=true
	key="rocky8"
        if grep -q -F "${key}" <<< "${value}"; then
            value2=$(sed -E "s/.*\b${key}=(true|false)($|,.*)/\1/" <<< "${value}")
	    if [[ ${value2} != "true" ]]; then
		is_rocky8=false
	    fi
        fi
	
        status="[ $ok ]"
        if ! ${is_rocky8}; then
            status="[$fail]"
	fi

        info=""
        echo "$status Requested resources: ${value}"
	
	key="h_rt"
        value2=$(sed -E "s/.*\b${key}=([[:digit:]]+)\b.*/\1/" <<< "${value}")
	s=${value2}

        echo "       - ${key}=${value2} => $(seconds_to_dhms "${value2}")"

        pattern_size="[[:digit:]]+([.][[:digit:]]*)?[[:alpha:]]?"
	key="mem_free"
	mem_free=(-1 -1 -1 -1 -1 -1 -1)
        if grep -q -F "${key}" <<< "${value}"; then
            value2=$(sed -E "s/.*\b${key}=(${pattern_size})($|,.*)/\1/" <<< "${value}")
	    mapfile -t mem_free < <(parse_size_spec "${value2}")
            echo "       - ${key}=${value2} => $(printf "%'.1f" "${mem_free[SIZES_MiB]}") MiB = $(printf "%'.1f" "${mem_free[SIZES_GiB]}") GiB"
        fi

	key="h_vmem"
        if grep -q -F "${key}" <<< "${value}"; then
            value2=$(sed -E "s/.*\b${key}=(${pattern_size})($|,.*)/\1/" <<< "${value}")
	    mapfile -t sizes < <(parse_size_spec "${value2}")
            echo "       - ${key}=${value2} => $(printf "%'.1f" "${sizes[SIZES_MiB]}") MiB = $(printf "%'.1f" "${sizes[SIZES_GiB]}") GiB"
        fi

	
	key="scratch"
        if grep -q -F "${key}" <<< "${value}"; then
            value2=$(sed -E "s/.*\b${key}=(${pattern_size})($|,.*)/\1/" <<< "${value}")
	    mapfile -t sizes < <(parse_size_spec "${value2}")
            echo "       - ${key}=${value2} => $(printf "%'.1f" "${sizes[SIZES_MiB]}") MiB = $(printf "%'.1f" "${sizes[SIZES_GiB]}") GiB"
        fi

        key="gpu_mem"
        if grep -q -F "${key}" <<< "${value}"; then
            value2=$(sed -E "s/.*\b${key}=(${pattern_size})($|,.*)/\1/" <<< "${value}")
	    mapfile -t sizes < <(parse_size_spec "${value2}")
            echo "       - ${key}=${value2} => $(printf "%'.1f" "${sizes[SIZES_MiB]}") MiB = $(printf "%'.1f" "${sizes[SIZES_GiB]}") GiB"
        fi

        key="eth_speed"
        if grep -q -F "${key}" <<< "${value}"; then
            value2=$(sed -E "s/.*\b${key}=([[:digit:]]+)($|,.*)/\1/" <<< "${value}")
            echo "       - ${key}=${value2}"
        fi
	
        key="compute_cap"
        if grep -q -F "${key}" <<< "${value}"; then
            value2=$(sed -E "s/.*\b${key}=([[:digit:]]+)($|,.*)/\1/" <<< "${value}")
            echo "       - ${key}=${value2}"
        fi

        key="hostname"
        if grep -q -F "${key}" <<< "${value}"; then
            value2=$(sed -E "s/.*\b${key}=([^,]+)($|,.*)/\1/" <<< "${value}")
            echo "       - ${key}=${value2}"
        fi

        if ! ${is_rocky8}; then
            echo "       - rocky8=${red}false${reset} <= ERROR: Not supported value"
        fi

        # shellcheck disable=2154
        value=${_THIS_JOB_parallel_environment}
        echo "[ $ok ] Parallel environment: ${value:-<none>}"

	## Number of parallel slots
	pattern="smp range: ([[:digit:]]+)"
	nslots=-1
        if grep -q -E "${pattern}" <<< "${_THIS_JOB_parallel_environment}"; then
	    nslots=$(sed -E "s/${pattern}/\1/" <<< "${_THIS_JOB_parallel_environment}")
	fi
	if [[ ${nslots} -gt 0 ]]; then
            echo "[ $ok ] Number of parallel slots: ${value:-<none>}"
	    mem_per_slot=$(printf "%.0f" "${mem_free[SIZES_MiB]}")
	    mem_total=$(( nslots * mem_per_slot / 1024 ))
            echo "[ $ok ] Total memory requested: ${mem_total:-<none>} GiB"
	fi
	
        # shellcheck disable=2154
        value=${_THIS_JOB_job_array_tasks}
        echo "[ $ok ] Job array tasks: ${value:-<none>}"

        # shellcheck disable=2154
        value=${_THIS_JOB_sge_o_shell}
        status="[ $ok ]"
	if [[ ! -x "${value}" ]]; then
            status="[$fail]"
	elif [[ "$(basename "${value}")" != "bash" ]]; then
            status="[$warn]"
        fi
        echo "${status} Job shell: ${value:-<none>}"
	
        # shellcheck disable=2154
        value=${_THIS_JOB_merge}
        status="[ $ok ]"
        echo "${status} Merge stdout and stderr: ${value:-<none>}"
	
        # shellcheck disable=2154
        value=${_THIS_JOB_notify}
        status="[ $ok ]"
        echo "${status} Signal job, if terminated: ${value:-<none>}"
	
        # shellcheck disable=2154
        value=${_THIS_JOB_cwd}
        status="[ $ok ]"
        info=""
	if [[ -z "${value}" ]]; then
            status="[$warn]"
            info=" ${yellow}WARNING: The job does not specify a working directory ('cwd')${reset}"
        elif ! ${is_owner}; then
            status="[$warn]"
        elif [[ ! -w "${value}" ]]; then
            # shellcheck disable=2154
            info=" ${red}ERROR: User '${_THIS_JOB_sge_o_log_name}' lacks write permission to folder${reset}"
            status="[$warn]"
	else
            info="$(dir_info "${value}" "${is_owner}")${info}"
        fi
        echo "${status} Working directory: ${info}"

        # shellcheck disable=2154
        value=${_THIS_JOB_sge_o_workdir}
        status="[ $ok ]"
        info=""
        if ! ${is_owner}; then
            status="[$warn]"
        elif [[ ! -w "${value}" ]]; then
            # shellcheck disable=2154
            info=" ${red}ERROR: User '${_THIS_JOB_sge_o_log_name}' lacks write permission to folder${reset}"
            status="[$fail]"
        fi           
        echo "${status} Log directory: $(dir_info "${value}" "${is_owner}")${info}"

        # shellcheck disable=2154
        value=${_THIS_JOB_job_args}
        echo "[ $ok ] Job script arguments: ${value:-<none>}"

        ## Was there a launch error?
        if [[ -n $_THIS_JOB_error_reason_1 ]]; then
            # shellcheck disable=2154
            echo "[$fail] ${red}ERROR: ${_THIS_JOB_error_reason_1}${reset}"
            exit
        fi

#        job_id=$(grep -E "^job_number:" <<< "${bfr}" | sed 's/^[^ ]*[ ]*//')
#        submit_time=$(grep -E "^submission_time:" <<< "${bfr}" | sed 's/^[^ ]*[ ]*//')
#	echo "$bfr"
	exit 0
    fi

    ## If not, then look it up in the archives
    bfr=$(tail -n "$tail_size" /opt/sge/wynton/common/accounting | qacct -f - -j "$jobid")
    res=$?
    if [[ $res -eq 0 ]]; then
	echo "$bfr"
	exit 0
    fi

    error "No such job ID among the last ${tail_size} records in the SGE accounting file: $jobid"
fi

