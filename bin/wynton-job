#! /usr/bin/env bash
### Wynton HPC Job Details
###
### Usage:
###  wynton-job [options] <job_id>
###
### Options:
###  --help           Display this help
###  --version        Display version
###
### Examples:
###  wynton job $JOBID
###
### Version: 0.1.1-9000
### Copyright: Henrik Bengtsson (2020-2023)
### License: GPL (>= 2.1) [https://www.gnu.org/licenses/gpl.html]

this="${BASH_SOURCE%/}"
[[ -L "${this}" ]] && this=$(readlink "${this}")

## Import bash utility functions
incl="$(dirname "${this}")/incl"

# shellcheck source=incl/asserts.sh
source "${incl}/asserts.sh"
# shellcheck source=incl/cli.sh
source "${incl}/cli.sh"
# shellcheck source=incl/conditions.sh
source "${incl}/conditions.sh"
# shellcheck source=incl/files.sh
source "${incl}/files.sh"
# shellcheck source=incl/output.sh
source "${incl}/output.sh"
# shellcheck source=incl/system.sh
source "${incl}/system.sh"

call="$0 $*"


# -------------------------------------------------------------------------
# CORE
# -------------------------------------------------------------------------
function mecho() { echo "$@" 1>&2; }

function mdebug() {
    if $debug; then
        mecho "[DEBUG] $*";
    fi
}
function merror() {
    mecho "ERROR: $*";
    exit 1
}
function vecho() {
    if $verbose; then
        echo "$@";
    fi
}

function ok() {
    echo "[ OK ]"
}

function fail() {
    echo "[FAIL]"
}

function dir_info() {
    local dir=${1:?}
    local is_owner=${2:true}
    local info
    info="'${dir}'"

    if [[ ! -d "${dir}" ]]; then
        if ${is_owner}; then
            info="${dir} ${red}ERROR: not a directory${reset}"
        else
            info="${dir} ${yellow}Cannot access directory because you ($USER) may lack access permissions${reset}"
        fi
        echo "${info}"
        return 1
    fi

    ## File-permission, username, and group
    info="${info} [$(stat -c "%A, owner=%U, group=%G" "${dir}")]"

    echo "${info}"
}

# -------------------------------------------------------------------------
# SPECIFIC
# -------------------------------------------------------------------------

## Enable terminal colors, if supported
term_colors enable

ok="${green}OK${reset}"
warn="${yellow}WARN${reset}"
fail="${red}FAIL${reset}"

# -------------------------------------------------------------------------
# MAIN
# -------------------------------------------------------------------------
## Actions
action=job

## Options
debug=false
verbose=false
jobid=

# Parse command-line options
while [[ $# -gt 0 ]]; do
    if test "$1" == "--help"; then
        action=help
    elif test "$1" == "--version"; then
        action=version
    elif test "$1" == "--debug"; then
        debug=true
    elif test "$1" == "--verbose"; then
        verbose=true
    else
        if [[ -z $jobid ]]; then
            jobid=$1
        else
            extras="$extras $1"
        fi
    fi
    shift
done

if $debug; then
    mdebug "call: $call"
    mdebug "action: $action"
    mdebug "verbose: $verbose"
    mdebug "jobid: $jobid"
fi

## Assert that the job ID is numeric, if specified
[[ -z $jobid ]] || [[ $jobid =~ ^[0-9]+$ ]] || merror "Non-numeric job ID: $jobid"


if [[ $action == "version" ]]; then
    version
    exit 0
elif [[ $action == "help" ]]; then
    help "full"
    exit 0
fi

if [[ $action == "job" ]]; then
    [[ -z $jobid ]] && merror "Job ID not specified"
    
    ## An active job?
    bfr=$(qstat -j "$jobid" 2> /dev/null)
    if [[ $? == 0 ]]; then
        ## Keep key: value lines
        vars=$(grep -E "^[^:]+:.*" <<< "$bfr")
        ## Fix keys
        vars=$(sed ':loop; s/^\([^:]*\) \+\([^:]*:\)/\1_\2/; t loop' <<< "$vars" | sed ':loop; s/^\([^:]*\)-\+\([^:]*:\)/\1_\2/; t loop' | sed -E 's/__+/_/g')
        ## Turn into _THIS_JOB_keys="value"
        vars=$(sed -E 's/^([^:]+):[[:space:]]*(.*)/_THIS_JOB_\1="\2"/' <<< "$vars")
	echo "------------------------"
        ## Parse as environment variables
        while IFS= read -r line; do
            eval "export $line"
        done <<< "$vars"
        env | grep -F "_THIS_JOB_" | sort

        ## Get additional info on the job
        bfr2=$(qstat -u "${_THIS_JOB_owner}" | grep -E "^[[:space:]]*\b${_THIS_JOB_job_number}\b[[:space:]]")

        ## Summarize
        ruler "-"
        echo "Job Details"
        ruler "-"
        echo

        value=${_THIS_JOB_job_number}
        echo "[ $ok ] Job ID: ${value}"

        value=${_THIS_JOB_job_name}
        echo "[ $ok ] Job name: ${value}"

        ## Current status
        mapfile -t values < <(awk '{ print $5 }' <<< "$bfr2")
        level=0
        values2=()
        for kk in $(seq "${#values[@]}"); do
            value=${values[$((kk - 1))]}

            value=${value/d/00}
            value=${value/E/01}
            value=${value/h/02}
            value=${value/q/03}
            value=${value/r/04}
            value=${value/R/05}
            value=${value/s/0S}
            value=${value/S/06}
            value=${value/t/07}
            value=${value/T/08}
            value=${value/w/09}
            value=${value/z/10}

            value=${value/00/${yellow}deletion${reset} }
            value=${value/01/${red}error${reset} }
            value=${value/02/${yellow}hold${reset} }
            value=${value/03/${yellow}queued${reset} }
            value=${value/04/${green}running${reset} }
            value=${value/05/${blue}restarted${reset} }
            value=${value/06/${yellow}suspended${reset} }
            value=${value/07/${blue}transfering${reset} }
            value=${value/08/${yellow}threshold${reset} }
            value=${value/09/${blue}waiting${reset} }
            value=${value/10/${red}zombie${reset} }

            if [[ $level -lt 2 ]]; then
                if [[ $value == *error* ]]; then
                    level=2
                elif [[ $value == *zombie* ]]; then
                    level=2
                fi
            fi

            if [[ $level -lt 1 ]]; then
                if [[ $value == *deletion* ]]; then
                    level=1
                elif [[ $value == *hold* ]]; then
                    level=1
                elif [[ $value == *queued* ]]; then
                    level=1
                elif [[ $value == *threshold* ]]; then
                    level=1
                fi
            fi
            values2+=("$value")
        done
        status="[ $ok ]"
        if [[ $level == 1 ]]; then
            status="[$warn]"
        elif [[ $level == 2 ]]; then
            status="[$fail]"
        fi
        echo "$status Job status: [n=${#values[@]}] ${values[*]} => ${values2[*]}"

        value=${_THIS_JOB_owner}
        is_owner=true
        status="[ $ok ]"
        info=""
        if [[ $value != $USER ]]; then
            is_owner=false
            status="[$warn]"
            info=" ${yellow}WARNING: You ($USER) are not the owner of this job${reset}"
        fi
        echo "$status Job owner: ${value}${info}"

        value=${_THIS_JOB_submission_time}
        status="[ $ok ]"
        info=""
        epoch=$(date -d "${value}" '+%s' 2> /dev/null)
	if [[ $? != 0 ]]; then
            timestamp="${value}"
            status="[$warn]"
            info=" ${yellow}WARNING: Failed to parse timestamp${reset}"
        else
            timestamp=$(date -d "@${epoch}" '+%A %Y-%m-%dT%H:%M:%S%z' 2> /dev/null)
	    epoch_now=$(date "+%s")
	    mins=$(( (epoch_now - epoch) / 60 ))
	    hours=$(( (epoch_now - epoch) / 3600 ))
	    days=$(( hours / 24 ))
            hours2=$(( hours - 24 * days ))
            mins2=$(( mins - 60 * hours ))
            info="${days}d${hours2}h${mins2}m ago"
            if [[ $hours -gt 24 ]]; then
                info="${red}${info}${reset}"
                status="[$warn]"
            elif [[ $hours -gt 6 ]]; then
                info="${yellow}${info}${reset}"
                status="[$warn]"
            fi
            info=" [${info}]"
        fi
        echo "$status Submitted on: ${timestamp}${info}"

        value=${_THIS_JOB_hard_queue_list}
        status="[ $ok ]"
        info=""
        echo "$status Job queue: ${value}"

        value=${_THIS_JOB_hard_resource_list}
        status="[ $ok ]"
        info=""
        echo "$status Requested resources: ${value}"
	
	key="h_rt"
        value2=$(sed -E "s/.*\b${key}=([[:digit:]]+)\b.*/\1/" <<< "${value}")
	s=${value2}
	m=$(( s / 60 ))
	h=$(( m / 60 ))
	d=$(( h / 24 ))
	h=$(( h - 24 * d ))
	m=$(( m - 60 * h ))
	s=$(( s - 60 * m ))
        echo "       - ${key}=${value2} => ${d}d-$(printf "%02dh%02dm%02ds" "${h}" "${m}" "${s}")"

	key="mem_free"
        if grep -q -F "${key}" <<< "${value}"; then
          value2=$(sed -E "s/.*\b${key}=([[:digit:]]+[[:alpha:]]?)\b.*/\1/" <<< "${value}")
  	  bytes=${value2}
	  bytes=${bytes//G/*1024M}
	  bytes=${bytes//M/*1024K}
	  bytes=${bytes//K/*1024}
	  bytes=$(bc <<< "${bytes}")
	  kB=$(bc <<< "${bytes} / 1000")
	  MB=$(bc <<< "${kB} / 1000")
	  GB=$(bc <<< "${MB} / 1000")
          echo "       - ${key}=${value2} => $(printf "%'d" "${bytes}") bytes = ~$(printf "%'d" "${kB}") kB = ~$(printf "%'d" "${MB}") MB = ~$(printf "%'d" "${GB}") GB"
        fi
	
        value=${_THIS_JOB_cwd}
        status="[ $ok ]"
        info=""
	if [[ -z "${value}" ]]; then
            status="[$warn]"
            info=" ${yellow}WARNING: 'qstat -j <job id>' does not have a 'cwd' variable${reset}"
        elif ! ${is_owner}; then
            status="[$warn]"
        elif [[ ! -w "${value}" ]]; then
            info=" ${red}ERROR: User '${_THIS_JOB_sge_o_log_name}' lacks write permission to folder${reset}"
            status="[$warn]"
        fi
	if [[ -d "${value}" ]]; then
	    info="$(dir_info "${value}" "${is_owner}")${info}"
	fi
        echo "${status} Working directory: ${info}"

        value=${_THIS_JOB_sge_o_workdir}
        status="[ $ok ]"
        info=""
        if ! ${is_owner}; then
            status="[$warn]"
        elif [[ ! -w "${value}" ]]; then
            info=" ${red}ERROR: User '${_THIS_JOB_sge_o_log_name}' lacks write permission to folder${reset}"
            status="[$fail]"
        fi           
        echo "${status} Log directory: $(dir_info "${value}" "${is_owner}")${info}"

        ## Was there a launch error?
        if [[ -n $_THIS_JOB_error_reason_1 ]]; then
            echo "[$fail] ${red}ERROR: ${_THIS_JOB_error_reason_1}${reset}"
            exit
        fi

#        job_id=$(grep -E "^job_number:" <<< "${bfr}" | sed 's/^[^ ]*[ ]*//')
#        submit_time=$(grep -E "^submission_time:" <<< "${bfr}" | sed 's/^[^ ]*[ ]*//')
#	echo "$bfr"
	exit 0
    fi

    ## If not, then look it up in the archives
    tail_size=1000000
    bfr=$(tail -n "$tail_size" /opt/sge/wynton/common/accounting | qacct -f - -j "$jobid")
    res=$?
    if [[ $res -eq 0 ]]; then
	echo "$bfr"
	exit 0
    fi

    merror "No such job ID: $jobid"
fi

